\subsection{Wat is een taal?}

\vspace{0.5cm}

\begin{theo}[String over een alfabet $\Sigma$]{String over een alfabet Sigma}
    Een \textbf{string} over een alfabet $\Sigma$ is een eindige opeenvolging van nul, één of meer elementen van $\Sigma$.
\end{theo}

\begin{app}[$\epsilon$-compressie van een string]{epsillon-compressie}
    Als we uit een string $w \in \Sigma_{\epsilon}$ elk voorkomen van $\epsilon$ schrappen, wat resulteert in een nieuwe string $s$, dan noemen we $s$ de $\epsilon$-compressie van $w$. 
\end{app}

\begin{theo}[Taal $L$ over een alfabet $\Sigma$]{Taal L over een alfabet Sigma}
    Een \textbf{taal} $L$ over een alfabet $\Sigma$ is een verzameling van strings over $\Sigma$.
\end{theo}

\subsection{Een algebra van talen}

\vspace{0.5cm}

\begin{theo}[Een algebra- of algebraïsche structuur]{Een algebra- of algebraïsche structuur}
    Een algebra- of algebraïsche structuur is een verzameling met daarop een aantal inwendige operaties: dikwijls binaire operaties, maar unair of met grotere ariteit kan ook. Zo wordt de verzameling van alle talen over een alfabet $\Sigma$ een algebra als we als operaties unie, doorsnede, complement, etc.\ definïeren. Meer concreet: als $L_1$ en $L_2$ twee talen zijn, dan is
    \begin{itemize}
        \item de unie ervan een taal: $L_1 \cup L_2$
        \item de doorsnede ervan een taal: $L_1 \cap L_2$
        \item het complement ervan een taal: $\overline{L_1}$
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\begin{pro}[Concatenatie van twee talen]{Concatenatie van twee talen}
    Gegeven twee talen $L_1$ en $L_2$ over hetzelfde alfabet $\Sigma$, dan noteren we de concatenatie van
    $L_1$ en $L_2$ als $L_1L_2$ en definïeren we:
    \begin{equation*}
        L_{1}L_{2} = \{ xy  \ | \ x \in L_1,  \ y \in L_2\}
    \end{equation*}
    \vspace{-0.5cm}
\end{pro}

\newpage

\begin{pro}[Kleene ster van een taal]{Kleene ster van een taa}
    De Kleene ster van een taal wordt gedefinieerd als volgt:
    \begin{equation*}
        L^* = \cup_{n \geq 0}L^n
    \end{equation*}
    \vspace{0.3cm}
    \textbf{Opmerking:} $L^+ = LL^*$
    \vspace{-0.3cm}
\end{pro}

\begin{app}[Kleene ster van een alfabet]{Kleene ster van een alfabet}
    De verzameling van alle strings over een alfabet $\Sigma$ is de kleene ster van het aflabet $\Sigma^*$, en volgt dus dat
    \begin{equation*}
        L \in \mathcal{P}(\Sigma^*)
    \end{equation*}
    \vspace{-0.5cm}
\end{app}

\subsection{Reguliere expressies en reguliere talen}

\vspace{0.5cm}

\begin{theo}[Reguliere Expressie (RE) over een alfabet $\Sigma$]{Reguliere Expressie (RE) over een alfabet Sigma}
    E is een \textbf{reguliere expressie} over een alfabet $\Sigma$ indien E van de vorm is
    \begin{itemize}
        \item $\epsilon$
        \item $\phi$
        \item $a$ waarbij $a \in \Sigma$
        \item ($E_{1}E_{2}$) waarbij $E_1$ en $E_2$ reguliere expressies zijn over $\Sigma$
        \item ($E_{1}^*$) waarbij $E_1$ een reguliere expressies is over $\Sigma$
        \item ($E_{1}|E_{2}$) waarbij $E_1$ en $E_2$ reguliere expressies zijn over $\Sigma$
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\begin{theo}[Reguliere taal]{Reguliere taal}
    Een reguliere expressie $E$ bepaalt een \textbf{reguliere taal} $L_E$ over hetzelfde alfabet $\Sigma$ als volgt:
    \begin{itemize}
        \item als $E = a \ (\text{met} \ a \in \Sigma)$ dan is $L_E = \{a\}$
        \item als $E = \epsilon$ dan is $L_E = \{\epsilon\}$
        \item als $E = \phi$ dan is $L_E = \emptyset$
        \item als $E = (E_{1}E_{2})$ dan $L_E = L_{E_1}L_{E_2}$
        \item als $E = {(E_{1})}^{*}$ dan $L_E = L_{E_1}^*$
        \item als $E = (E_{1}|E_{2})$ dan $L_E = L_{E_1} \cup L_{E_2}$
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\newpage

\subsection{Niet-deterministische eindge toestandsautomaten}

\vspace{0.5cm}

\begin{theo}[Niet-deterministische eindige toestandsautomaat (NFA)]{Niet-deterministische eindige toestandsautomaat}
    Een \textbf{niet-deterministische eindige toestandsautomaat} is een 5-tal $(Q,\Sigma, \delta, q_s, F)$ waarbij

    \vspace{0.5cm}

    \begin{minipage}{.61\textwidth}
        \begin{itemize}
            \item $Q$ een eindige verzameling toestanden is
            \item $\Sigma$ is een eindig alfabet
            \item $\delta \subseteq Q \times \Sigma_{\epsilon} \times Q$ is de overgangsrelatie van de automaat, wat kan worden voorgesteld in een transitietabel
            \item $q_s$ is de starttoestand
            \item $F \subseteq Q$ is de verzameling eindtoestanden
        \end{itemize}
    \end{minipage}
    \hspace{0.3cm}
    \begin{minipage}{.35\textwidth}
        \begin{center}
            \includegraphics[scale = 0.25]{Images/NFA}
        \end{center}
    \end{minipage}

    \vspace{0.5cm}

    \textbf{Opmerking:} In de literatuur wordt $\delta$ soms ook als een functie gedefinieerd die een toestand en een symbool afbeeldt op de verzameling van toestanden waarnaar een overgang mogelijk is:
    \begin{equation*}
        \delta(q,a) = \{ q' \in Q \ | \ (q,a,q') \in \delta \}.
    \end{equation*}
    We schrijven $p \overset{a}{\to} q$ om aan te geven dat $(p,a,q)$ een overgang is in $\delta$.
    % \vspace{-0.3cm}
\end{theo}
    
\begin{theo}[Een string $s$ wordt aanvaard door een NFA]{Een string s wordt aanvaard door een NFA}
    Een string $s$ wordt aanvaard door een NFA $(Q,\Sigma, \delta, q_s, F)$ indien
    er een sequentie $q_s = q_0 \overset{a_0}{\to} \ldots \overset{a_{n-1}}{\to} q_n$
    van overgangen bestaat met $q_n \in F$ zodat s de $\epsilon$-compressie is van $a_0 \ldots a_{n-1}$. \\
    
    \noindent \textbf{Dus:} Voor toestanden $p$,$q$ en string $w \in \Sigma^*$ schrijven we $p \overset{w}{\rightsquigarrow} q$
    indien er een sequentie van overangen $ p \overset{a_0}{\to} \ldots \overset{a_{n-1}}{\to} q$ bestaat zodat $w$
    de $\epsilon$-compressie is van $a_0 \ldots a_{n-1}$.
\end{theo}

\begin{theo}[De taal door een NFA $M$ bepaald]{De taal door een NFA M bepaald}
    Een taal $L$ wordt bepaald door een NFA $M$, indien $L$ de verzameling van strings is die $M$ aanvaardt.
    We noteren de taal van $M$ als $L_M$.
\end{theo}

\begin{theo}[Equivalentie van twee NFA's]{Equivalentie van twee NFA's}
    Twee NFA's worden \textbf{equivalent} genoemd als ze dezelfde taal bepalen, m$.$a$.$w$.$ elke equivalentieklassen van deze equivalentierelatie komt overeen met een taal.
\end{theo}

\newpage

\subsection{De algebra van NFA's}

\vspace{0.5cm}

\begin{pro}[De unie van twee NFA's]{De unie van twee NFA's}
    \underline{Gegeven}: $i \in \{1,2\}: \ \text{NFA}_i = (Q_i,\Sigma, \delta_i, q_{s_i}, \{q_{f_i}\})$ \\
    
    % $\text{NFA}_1 = (Q_1,\Sigma, \delta_1, q_{s_1}, \{q_{f_1}\})$ en $\text{NFA}_2 = (Q_2,\Sigma, \delta_2, q_{s_2}, \{q_{f_2}\})$ \\

    \begin{minipage}{.6\textwidth}
        De unie $\text{NFA}_1 \cup \text{NFA}_2$ is de $\text{NFA} = (Q,\Sigma, \delta, q_s, F)$ waarbij 
        \begin{itemize}
            \item $Q = Q_1 \cup Q_2 \cup \{ q_s, q_f \}$, $F = \{q_f\}$
            \item $\delta$  is gedefnieerd als:
            \begin{itemize}
                \item $\forall x \in \Sigma: \delta(q_s, x) = \emptyset \ \land \ \delta(q_{f_{i}}, x) = \emptyset$
                % \item $\forall x \in \Sigma: \delta(q_{f_{i}}, x) = \emptyset$
                \item $\forall q \in Q_{i} \backslash \{q_{f_{i}}\}, \ x \in \Sigma_{\epsilon}: \ \delta(q,x) = \delta_i(q,x)$
                \item $\delta(q_s, \epsilon) = \{q_{s_{1}}, q_{s_{2}}\}$
                \item $\delta(q_{f_{i}}, \epsilon) = \{q_f\}$
            \end{itemize}
        \end{itemize}
    \end{minipage}
    % \hspace{-0.5cm}
    \begin{minipage}{.36\textwidth}
        \includegraphics[scale = 0.225]{Images/UnieNFA}
    \end{minipage}
\end{pro}

\begin{pro}[De concatenatie van twee NFA's]{De concatenatie van twee NFA's}
    \underline{Gegeven}: $i \in \{1,2\}: \ \text{NFA}_i = (Q_i,\Sigma, \delta_i, q_{s_i}, \{q_{f_i}\})$ \\

    De concatenatie $\text{NFA}_1\text{NFA}_2$ is de $\text{NFA} = (Q,\Sigma, \delta, q_s, F)$ waarbij \\

    \vspace{-0.2cm}
    \begin{minipage}{.6\textwidth}
        \begin{itemize}
            \item $Q = Q_1 \cup Q_2$, $q_s = q_{s_1}$, $F = \{q_{f_2}\}$
            \item 
                $\delta$ is gedefnieerd als:
                \begin{itemize}
                    \item $\forall x \in \Sigma: \ \delta{q_{f_1}, x} = \emptyset$
                    \item $\forall q \in Q_{i}\backslash \{q_{f_1}\}, \ x \in \Sigma_{\epsilon}: \ \delta(q,x) = \delta_i(q,x)$
                    \item $\delta(q_{f_1}, \epsilon) = \{q_{s_2}\}$
                \end{itemize}
        \end{itemize}
        % \begin{itemize}
        %     \item $Q = Q_1 \cup Q_2 \cup \{ q_s, q_f \}$
        %     \item $F = \{q_f\}$
        %     \item $\delta$ is gedefnieerd als:
        %     \begin{itemize}
        %         \item $\forall q \in Q_{i} \backslash \{q_{f_{i}}\}, \ x \in \Sigma_{\epsilon}, \ i = 1,2: \ \delta(q,x) = \delta_i(q,x)$
        %         \item $\delta(q_s, \epsilon) = \{q_{s_{1}}, q_{s_{2}}\}$
        %         \item $\forall x \in \Sigma: \delta(q_s, x) = \emptyset$
        %         \item $i = 1,2: \delta(q_{f_{i}}, \epsilon) = \{q_f\}$
        %         \item $\forall x \in \Sigma, i = 1,2: \delta(q_{f_{i}}, x) = \emptyset$
        %     \end{itemize}
        % \end{itemize}
    \end{minipage}
    \hspace{-0.5cm}
    \begin{minipage}{.36\textwidth}
        \includegraphics[scale = 0.28]{Images/ConcatNFA}
    \end{minipage}
    % \begin{center}
    %     \includegraphics[scale = 0.35]{Images/ConcatNFA}
    % \end{center}
\end{pro}

\begin{pro}[De ster van een NFA]{De ster van een NFA}
    \underline{Gegeven}: $\text{NFA}_1 = (Q_1,\Sigma, \delta_1, q_{s_1}, \{q_{f_1}\})$ \\

    De Kleene ster $\text{NFA}_1^*$ is de NFA $= (Q,\Sigma, \delta, q_s, F)$ waarbij \\

    \vspace{-0.1cm}
    \begin{minipage}{.56\textwidth}
        \begin{itemize}
            \item $Q = Q_1 \cup \{q_s, q_f\}$, $F = \{q_f\}$
            \item 
                $\delta$ is gedefnieerd als:
                \begin{itemize}
                    \item $\forall x \in \Sigma: \delta(q_{s}, x) = \emptyset \ \land \ \delta(q_{f_1}, x) = \emptyset$
                    % \item $\forall x \in \Sigma: \delta(q_{s}, x) = \emptyset$
                    \item $\forall q \in Q_{1}\backslash \{q_{f_1}\}, \ x \in \Sigma_{\epsilon}: \ \delta(q,x) = \delta_1(q,x)$
                    \item $\delta(q_s, \epsilon) = \{q_{s_1}, q_{f_1}\}$
                    \item $\delta(q_{f_1}, \epsilon) = \{q_{s}, q_{f}\}$
                \end{itemize}
        \end{itemize}
        % \begin{itemize}
        %     \item $Q = Q_1 \cup Q_2 \cup \{ q_s, q_f \}$
        %     \item $F = \{q_f\}$
        %     \item $\delta$ is gedefnieerd als:
        %     \begin{itemize}
        %         \item $\forall q \in Q_{i} \backslash \{q_{f_{i}}\}, \ x \in \Sigma_{\epsilon}, \ i = 1,2: \ \delta(q,x) = \delta_i(q,x)$
        %         \item $\delta(q_s, \epsilon) = \{q_{s_{1}}, q_{s_{2}}\}$
        %         \item $\forall x \in \Sigma: \delta(q_s, x) = \emptyset$
        %         \item $i = 1,2: \delta(q_{f_{i}}, \epsilon) = \{q_f\}$
        %         \item $\forall x \in \Sigma, i = 1,2: \delta(q_{f_{i}}, x) = \emptyset$
        %     \end{itemize}
        % \end{itemize}
    \end{minipage}
    % \hspace{-0.1cm}
    \begin{minipage}{.4\textwidth}
        \includegraphics[scale = 0.325]{Images/SterNFA}
    \end{minipage}
    % \begin{center}
    %     \includegraphics[scale = 0.4]{Images/SterNFA}
    % \end{center}
\end{pro}

\subsection{Van RE naar NFA}

\vspace{0.5cm}

\begin{theo}[Van RE naar NFA]{Van RE naar NFA}
    We hebben alle ingrediënten om van een reguliere expressie RE een NFA te maken, en zodanig dat de $L_{RE} = L_{NFA}$.
    Vermits reguliere expressies inductief gedefinieerd zijn zullen we voor elk lijntje van die definitie een overeenkomstige NFA definiëren.
    De drie basisgevallen $\epsilon$, $\phi$ en $a \in \Sigma$ zijn triviaal te modeleren als NFA.
    We illusteren hieronder:
    \begin{center}
        \includegraphics[scale = 0.275]{Images/NFABasisGevallen.png}
    \end{center}
    De drie recursieve gevallen beschrijven we als volgt: laat $E_{1}$ en $E_{2}$ twee reguliere expressies zijn, dan is
    \begin{itemize}
        \item $NFA_{E_{1}E_{2}} = \text{concat}(NFA_{E_{1}},NFA_{E_{2}})$
        \item $NFA_{E_{1}^{*}} = \text{ster}(NFA_{E_{1}})$
        \item $NFA_{E_{1}|E_{2}} = \text{unie}(NFA_{E_{1}},NFA_{E_{2}})$
    \end{itemize}
    \noindent De constructie hierboven bewaart de taal, t.t.z. $L_{NFA_{E}} = L_{E}$.
\end{theo}

\subsection{Van NFA naar RE}

\vspace{0.5cm}

\begin{theo}[GNFA]{GNFA}
    Een \textbf{GNFA} is een eindige toestandsmachine met de volgende wijzigingen en beperkingen: \\

    % \begin{itemize}
    %     \item er is slechts één eindtoestand en die is verschillend van de starttoestand
    %     \item vanuit de starttoestand vertrekt er juist één boog naar elke andere toestand; er komen geen bogen aan in de starttoestand
    %     \item in de eindtoestand komt juist één boog aan vanuit elke andere toestand; uit de eindtoestand vertrekken geen bogen
    %     \item voor paar \(p\),\(q\) (let op: p = q is geldig) van andere toestanden (geen start- of eindtoestand) is er juist één boog van \(p \to q\) en één boog van \(q \to p\).
    %     \item  de bogen hebben als label een reguliere expressie
    % \end{itemize} 
    \begin{minipage}{.56\textwidth}
        \begin{itemize}
            \item er is slechts één eindtoestand en die is verschillend van de starttoestand
            \item vanuit de starttoestand vertrekt er juist één boog naar elke andere toestand; er komen geen bogen aan in de starttoestand
            \item in de eindtoestand komt juist één boog aan vanuit elke andere toestand; uit de eindtoestand vertrekken geen bogen
            \item voor paar \(p\),\(q\) (let op: \(p\) = \(q\) is geldig) van andere toestanden (geen start- of eindtoestand) is er juist één boog \(p \to q\) en één boog \(q \to p\).
            \item  de bogen hebben als label een reguliere expressie
        \end{itemize} 
    \end{minipage}
    \hspace{0.1cm}
    \begin{minipage}{.4\textwidth}
        \includegraphics[scale = 0.35]{Images/GNFA.png}
    \end{minipage}
\end{theo}

\newpage

\begin{alg}[NFA $\to$ RE]{NFA naar RE}
    \begin{enumerate}
        \item Maak van de NFA een GNFA
        \begin{itemize}
            \item Behoud alle toestanden en bogen van de NFA
            \item Als er meerdere bogen zijn tussen twee toestanden gelabeld met symbolen \(a_{1} \ldots a_{n} \) vervang deze door één boog met als label \(a_{1} | \ldots | a_{n} \)
            \item Voer een nieuwe starttoestand in en een \(\epsilon\)-boog naar de oude starttoestand
            \item Voer een nieuwe eindtoestand in en \(\epsilon\)-bogen vanuit elke oude eindtoestand
            \item Voor elke boog die ontbreekt tussen twee toestanden om een GNFA te bekomen, voer een \(\phi\)-boog in
        \end{itemize}
        \item Reduceer de GNFA: \vspace{0.3cm} \\
            \begin{minipage}{.453\textwidth} 
                Kies een willekeurige toestand \(X\) verschillend van de start- of eindtoestand, ga naar stap 3 als dit niet mogelijk is.
                Voor elk paar toestanden \(A\) en \(B\) (let op: \(A\) = \(B\) is geldig) verschillend van X bevat de GNFA een unieke boog \(A \to B\) met label \(E_{4}\), 
                \(A \to X\) met label \(E_{1}\), \(X \to X\) met label \(E_{2}\) en \(X \to B\) met label \(E_{3}\). Vervang het label op de boog \(A \to B\) door \(E_{4} | E_{1}E_{2}^{*}E_{3}\).
                Doe dit voor alle keuzes voor A en B. Verwijder daana de knoop X en herhaal.
            \end{minipage}
            \begin{minipage}{.43\textwidth}
                \hspace{0.3cm}\includegraphics[scale = 0.375]{Images/GNFAToestandVerwijderen}
            \end{minipage}
        \item Bepaal RE: de boog van de GNFA heeft als label de gezochte RE
    \end{enumerate}
\end{alg}

\newpage

\subsection{Deterministische eindige toestandsmachines}

\vspace{0.5cm}

\begin{theo}[Deterministische eindige toestandsmachines]{Deterministische eindige toestandsmachines}
    Een NFA is een DFA indien \(\delta\) geen \(\epsilon\)-overgangen bevat en 
    indien voor elke \(p \in Q\) en elke \(a \in \Sigma\) een unieke \(q \in Q\) 
    bestaat zodat \(p \overset{a}{\to} q\). Het komt erop neer dat in een DFA, \(\delta\) 
    een totale functie $Q \times \Sigma \to Q$ is. Voor DFA's zullen a
    we de unieke toestand q zodat \(p \overset{a}{\to} q\) dan ook noteren als \(\delta(p,a)\).
\end{theo}

\begin{pro}[Doorsnede, verschil en complement van DFA's]{Doorsnede, verschil en complement van DFA's}
    \underline{Gegeven}: ${\text{DFA}}_1 = (Q_1,\Sigma, \delta_1, q_{s_1}, \{q_{f_1}\})$ en ${\text{DFA}}_2 = (Q_2,\Sigma, \delta_2, q_{s_2}, \{q_{f_2}\})$ \\

    We maken een generische pdoruct DFA $(Q,\Sigma, \delta, q_s, F)$ als volgt:
    \begin{itemize}
        \item $Q = Q_1 \times Q_2$
        \item $\delta(p \times q, x) = \delta_1(p,x) \times \delta_2(q,x)$
        \item $q_s = (q_{s_1},q_{s_2})$
        \item 
            Om tot een volledig definitie te komen, moeten we nog $F$ bepalen:
            \begin{itemize}
                \item $F = F_1 \times F_2$: de DFA is de doorsnede van de twee talen
                \item $F = (F_1 \times Q_2) \cup (Q_1 \times F_2)$: de DFA is nu de unie van de twee talen
                \item $\forall i \neq j \in [1,2]: \ F =  F_i \times (Q_j \times F_j)$: de DFA bepaalt nu de strings die tot $L_i$ behoren, maar niet tot $L_j$
                \item $F = (Q_1 \backslash F_1) \times (Q_2 \backslash F_2)$: de DFA bepaalt nu de strings die tot geen van beide talen behoren.
            \end{itemize}
    \end{itemize}
    Hieruit volgt ook dat de unie, doorsnede en complement van twee reguliere talen ook regulier zijn. Daaruit volgt ook dat het
    complement van een reguliere taal ook regulier is, want $\overline{L} = \Sigma^* \backslash L$.
\end{pro}

\begin{lem}[DFA en NFA equivalentie]{DFA en NFA equivalentie}
    Elke NFA is equivalent met een DFA, m$.$a$.$w$.$ we kunnen elke NFA \((Q, \Sigma, \delta, q_s, F)\) herleiden tot een
    equivalente DFA \((Q', \Sigma, \delta', q_s', F')\) waarbij
    \begin{itemize}
        \item \(Q'\): de verzameling van alle deelverzamelingen $q'$ van $Q$ die gesloten zijn onder \(\epsilon\)-bogen, dus
              \(p \in q' \ \wedge \ p \overset{\epsilon}{\to} q \ \Rightarrow \ q \in q'\)
        \item \(\delta': Q' \times \Sigma \rightarrow Q'\)
        \item \(q_{s}' = \{q_s,q \ | \ q_s \overset{\epsilon}{\rightsquigarrow} q \}\)
        \item \(F' = \{q' \in Q' \ | \ q' \cap F \neq \emptyset \}\)
    \end{itemize}
    \vspace{-0.3cm}
\end{lem}

\newpage

\begin{prf}[DFA en NFA equivalentie]{prf - DFA en NFA equivalentie}
    Uit constructie volgt dat de geconstrueerde automaat \((Q', \Sigma, \delta', q_s', F')\) een DFA is.
    Wat betreft equivalentie, moeten we verifiëren dat \(\forall w \in \Sigma^*:  q_s \overset{w}{\rightsquigarrow} F \Leftrightarrow q_s' \overset{w}{\rightsquigarrow} F'\). 
    De essentie van dat bewijs is dat voor elke \(w \in \Sigma^*\), als in de DFA geldt dat \(q_s' \overset{w}{\rightsquigarrow} q\) (in de DFA) dan is \(q\ = q_w = \{ q \ | \ q_s \overset{w}{\rightsquigarrow} q \}\) (in de NFA).
    Dit is eenvoudig inductief te bewijzen gebruik makend van het feit dat \(q' = q_w' \Rightarrow \delta'(q',a) = q_{wa}'\). Dan geldt dat de 
    DFA een string $w$ aanvaardt als voor de unieke toestand \(q'\) zodat \(q_s' \overset{w}{\rightsquigarrow} q'\) geldt dat \(q' \cap F \neq \emptyset \ \Leftrightarrow \ q_w' \cap F \neq \emptyset \ \Leftrightarrow\) de NFA aanvaardt w.
\end{prf}

\begin{theo}[$f$-string]{f-string}
    We noemen een string $s$ een $f$-string vanuit $q$ van de DFA indien \(\delta^*(q,s) \in F\), t$.$t$.$z$.$ indien er een pad is van $q$ naar een toestand van $F$ die s genereert. $F$-gelijke toestanden
    zijn dan toestanden met dezelfde $f$-strings. \vspace{0.3cm}\\
    \textbf{Opmerking:} \(q \in F \Leftrightarrow \epsilon \text{ is een $f$-string vanuit $q$}\)
\end{theo}

\begin{theo}[$f$-gelijk]{f-gelijk}
    Twee toestanden \(q_1,q_2\) zijn $f$-gelijk indien
    \begin{equation*}
        \{ s \in \Sigma^* \ | \ \delta^*(q_1,s) \in F\} = \{s \in \Sigma^* \ | \ \delta^*(q_2,s) \in F\}
    \end{equation*}
    In woorden, als $q_1$ en $q_2$ exact dezelfde $f$-strings hebben.
\end{theo}

\begin{pro}[$f$-gelijk]{pro - f-gelijk}
    \begin{itemize}
        \item De relatie $f$-gelijk is een equivalentie-relatie.
        \item Als $p,q$ $f$-gelijk zijn dan geldt voor elk symbool $a$ dat \(\delta(p,a)\) en \(\delta(q,a)\) ook $f$-gelijk zijn.
        \item Als $p,q$ $f$-gelijk zijn dan geldt \(p \in F \Leftrightarrow q \in F\).
    \end{itemize}
\end{pro}

\begin{prf}[Eigenschappen van de $f$-gelijk relatie]{prf - Eigenschappen van de f-gelijk relatie}
    \begin{itemize}
        \item Het is triviaal om te bewijzen dat $f$-gelijkheid een equivalentie-relatie is. Dit kan je doen door de reflexiviteit, symmetrie en transitiviteit van de relatie na te gaan.
        \item Veronderstel dat $p,q$ $f$-gelijk zijn en veronderstel voor een willekeurig symbool $a$ dat \(\delta(p,a) = p', \delta(q,a) = q'\). De $f$-strings van $p$ en $q$ zijn gelijk,
              en dus ook hun $f$-strings van de vorm $as$. De $f$-strings van $p'$ zijn de strings $s$ zodat $as$ een $f$-string is van $p$.
              Hetzelfde geldt voor $q'$. Bijgevolg hebben $p',q'$ dezelfde $f$-strings en zijn ze dus $f$-gelijk.
        \item Als $p$ en $q$ $f$-gelijk zijn, en $p \in F$ dan is $\epsilon$ een $f$-string van $p$ en dus ook van $q$. Aangezien er in een DFA geen $\epsilon$-bogen zijn, is $q \in F$.
              Hetzelfde geldt in de andere richting. 
    \end{itemize}
    \vspace{-0.5cm}
\end{prf}

\newpage

\begin{theo}[Minimale DFA]{Minimale DFA}
    Een DFA is minimaal als er geen enkele andere DFA bestaat die dezelfde taal bepaalt en minder toestanden heeft, m$.$a$.$w$.$ 
    DFA$_{\text{min}}$ is een DFA, equivalent met DFA, en alle toestanden zijn $f$-verschillend.
    \vspace{-0.3cm}
\end{theo}

\begin{lem}[DFA$_{\text{min}}$]{minDFA}
    \begin{itemize}
        \item DFA$_{\text{min}}$ is een DFA, equivalent met DFA, en alle toestanden zijn $f$-verschillend.
        \item Als een DFA $N$ = $(Q_1,\Sigma, \delta_1, q_s, F_1)$  een DFA is zonder onbereikbare toestanden en waarin elke twee toestanden $f$-verschillend zijn, 
        dan bestaat er geen machine met strikt minder toestanden die dezelfde taal bepaalt.
    \end{itemize}
\end{lem}

\begin{prf}[DFA$_{\text{min}}$]{prf - minDFA}
    \begin{itemize}
        \item 
        DFA$_min$ is een DFA omdat $f$-gelijkheid van toestanden $p$ en $q$ de $f$-gelijkheid van \(\delta(p,a)\) en \(\delta(q,a)\) impliceert. Het gevolg is dat verschillende bogen met hetzelfde symbool
        vanuit $f$-gelijke $p$ en $q$ versmelten. Om aan te tonen dat DFA en DFA$_{\text{min}}$ equivalent zijn, is de essentiële eigenschap dat elke equivalentie-klasse $Q_i$ en elk element \(p \in Q_i\)
        dezelfde $f$-strings heeft. Dus heeft $\tilde{q}_s$ dezelfde $f$-strings als $q_s$, en deze verzameling is dus de taal die beide DFA's bepalen. Aantonen dat een string $w$ een $f$-string is van $Q_i$
        als en slechts als $w$ een $f$-string is van \(q \in Q_i\) gebeurt door inductie op de lengte van $w$, gebruikmakend van het feit dat voor elke \(Q_i,Q_j\)
        \begin{equation*}
            p \in Q_i, \ q \in Q_j, \ \forall a \in \Sigma: \ Q_i \overset{a}{\to} Q_j \ \Leftrightarrow \ p \overset{a}{\to} q 
        \end{equation*}
        Tenslotte, twee verschillende toestanden $Q_i, Q_j$ bevatten $f$-verschillende toestanden. Aangezien de $f$-strings van $Q_i$ en $Q_j$ die van hun elementen zijn, zijn ze $f$-verschillend.
        \item    
        Veronderstel dat \(Q_1 = \{q_s,q_1, \ldots, q_n\}\) waarbij \(q_s\) de starttoestand is. 
        Stel dat \(N_2 = (Q_2,\Sigma, \delta_2, q_s, F_2)\) een DFA is met minder toestanden dan $N$.
        Vermits in $N$ elke toestand bereikbaar is, bestaan er strings \(\forall i \in \mathbb{N}_0^+: s_i\) zodanig dat \(\delta_1^*(q_s,s_i) = q_i\). 
        Vermits \(N_2\) minder toestanden heeft moet voor een \(i \neq j: \delta_2^*(p_s,s_i) = \delta_2^*(p_s,s_j)\). Vermits \(q_i\) en \(q_j\)
        $f$-verschillend zijn, is er een string \(s\) zodat \(\delta_1^*(q_i,s) \in F_1\) en \(\delta_1^*(q_j,s) \notin F_1\) of omgekeerd.
        Dus ook \(\delta_1^*(q_s,s_is) \in F_1\) en \(\delta_1^*(q_s,s_js) \notin F_1\) of omgekeerd. Dit betekent dat DFA$_1$ van de strings $s_is$ en $s_js$ er juist één accepteert.
        Maar N$_2$ zal beide strings $s_is$ en $s_js$ accepteren of geen van beiden, aangezien het parsen van $s_i$ en $s_j$ naar dezelfde node leidt, waarna hetzelfde pad gevolgd wordt om $v$ te parsen.
        Dus kunnen de DFA's N en N$_2$ niet dezelfde taal bepalen.
    \end{itemize}
\end{prf}

\newpage

\begin{theo}[DFA isomorfisme]{DFA isomorfisme}
    Een DFA $N_1 = (Q_1, \Sigma, \delta_1, q_{s_1}, F_1)$ is \textbf{isomorf} met een DFA $N_2 = (Q_2, \Sigma, \delta_2, q_{s_2}, F_2)$ als er een bijectie $b: Q_1 \to Q_2$ bestaat zodanig dat
    \begin{itemize}
        \item $b(F_1) = F_2$
        \item $b(q_{s_1}) = q_{s_2}$
        \item $b(\delta_1(q,a)) = \delta_2(b(q),a)$
    \end{itemize}
    Twee isomorfe DFA's bepalen dus dezelfde taal.
\end{theo}

\subsection{Myhill-Nerode relaties op $\Sigma^*$}

\vspace{0.5cm}

\begin{theo}[Fijnheid van partities]{Fijnheid van partities}
    Een partitie $P_1$ is \textbf{fijner} dan een partitie $P_2$ indien
    \begin{equation*}
        \forall x \in P_1,\ \exists y \in P_2: \ x \subseteq y
    \end{equation*}
    Het omgekeerde van fijn is \textbf{grof}.
\end{theo}

\begin{theo}[$\sim_{\text{DFA}}$]{DFAeqklassen}
    Voor een DFA $N = (Q, \Sigma, \delta, q_s, F)$ definiëren we de relatie $\sim_{\text{DFA}}$ op $\Sigma^*$ als volgt:
    \begin{equation*}
        x \sim_{\text{DFA}} y \ \Leftrightarrow \ \delta^*(q_s,x) = \delta^*(q_s,y)
    \end{equation*}
    In woorden: er geldt $x \sim_{\text{DFA}} y$ als en slechts als het parsen van $x$ en $y$ vanuit $q_s$ leidt tot dezelfde toestand $q$, dus $x,y \in \text{reach}(q)$.
\end{theo}

\begin{pro}[$\sim_{\text{DFA}}$]{pro - DFAeqklassen}
    \begin{itemize}
        \item Rechts congruentie van $\sim$: $\forall x,y \in \Sigma^*, \ a \in \Sigma: \ x \sim y \ \Rightarrow \ xa \sim ya $
        \item het aantal equivalentieklassen van $\sim$ is eindig, m$.$a$.$w$.$ $\sim$ heeft een eindige index
        \item $\sim$ verfijnt $\sim_L$, of: $x \sim y \ \Rightarrow \ x \sim_L y$
    \end{itemize}
\end{pro}

\begin{theo}[Myhill-Nerode relatie]{Myhill-Nerode relatie}
    Een equivalentierelatie $\sim$ tussen strings is een \textbf{Myhill-Nerode relatie} voor een taal $L$ als de equivalentieklasse
    voldoet aan bovenstaande eigenschappen. We schrijven: $\sim$ is MN(L)
\end{theo}

\begin{lem}[DFA$_{\sim}^{\text{L}}$]{DFAsimL}
    Gegeven een taal $L$ over $\Sigma$ en een MN(L)-relatie $\sim$ op $\Sigma^*$, dan is DFA$_{\sim}^{\text{L}} = (Q, \Sigma, \delta, q_s, F)$ een DFA die L bepaalt, waarbij
    \begin{itemize}
        \item $Q = \{x_{\sim} \ | \ x \in \Sigma^* \}$
        \item $\delta(x_{\sim},a) = (xa)_{\sim}$
        \item $q_s = \epsilon_{\sim}$
        \item $F = \{x_{\sim} \ | \ x \in L \}$
    \end{itemize}  
    \vspace{-0.3cm}
\end{lem}

\begin{prf}[DFA$_{\sim}^{\text{L}}$]{prf - DFAsimL}
    Dat $\delta$ goed gedefinieerd is, kan je bewijzen door gebruik te maken van de rechtse congruentie van $\sim$.
    Verder zijn alle ingrediënten van de DFA duidelijk, in het bijzonder ook dat $Q$ slechts een eindig aantal toestanden bevat.
    We moeten nog bewijzen dat $L_{\text{DFA}_{\sim}^{\text{L}}} = L$:
    \begin{equation*}
        x \in L_{\text{DFA}_{\sim}^{\text{L}}} \ \Leftrightarrow \ \delta^*(q_s,x) \in F \ \Leftrightarrow \ x_{\sim} \in F \ \Leftrightarrow \ x \in L
    \end{equation*}
    De middelste overgang bekom je door met inductie op de lengte van de string $x$ te bewijzen dat $\delta^*(\epsilon_{\sim},x) = (x)_{\sim}$.
\end{prf}

\begin{lem}[$\sim_{\text{DFA}}$ en $\sim$ zijn elkaars inverse]{simDFA en sim zijn elkaars inverse}
    Voor elke taal $L$ geldt dat de functie die DFA's van $L$ afbeeldt op de de overeenkomstige MN(L)-relatie $\sim_{\text{DFA}}$ en de functie 
    die MN(L)-relaties $\sim$ afbeeldt op de overeenkomstige DFA$_{\sim}^{\text{L}}$, elkaars inversen zijn op een DFA-isomorfisme na.
\end{lem}

% \begin{prf}[$\sim_{\text{DFA}}$ en $\sim$ zijn elkaars inverse]{simDFA en sim zijn elkaars inverse}
% \end{prf}

\begin{lem}[Infimumrelatie van Myhill-Nerode relaties]{Infimumrelatie van Myhill-Nerode relaties}
    Als $E$ een niet lege verzameling van MN(L) relaties is, dan is ook het infimum $\sim_{\text{inf}}$ van $E$ een MN(L)-relatie.
    $\sim_{\text{inf}}$ is de transitieve sluiting van de unie van $E$. Dit betekent dat
    \begin{equation*}
        x \sim_{\text{inf}} y \ \Leftrightarrow \ i \in [0, n-1], \ \sim_i \in E: \ x = x_0 \sim_0 x_1 \sim_1 \ldots \sim_{n-1} x_n = y
    \end{equation*}
    \vspace{-0.5cm}
\end{lem}

\newpage

\begin{prf}[Infimumrelatie van Myhill-Nerode relaties]{prf - Infimumrelatie van Myhill-Nerode relaties}
    We zagen al dat het infimum van een niet lege verzameling $E$ van equivalentierelaties zelf ook een equivalentierelatie is.

    \begin{itemize}
        \item 
            \textbf{Eindigheid:} $\sim_{\text{inf}}$ is een superset van elke willekeurige $\sim \in E$ en heeft dus minder equivalentieklassen
            dan $\sim$. Elke $\sim$ heeft slechts een eindig aantal equivalentieklasse, zodoende ook $\sim_{\text{inf}}$.
        \item 
            \textbf{Rechts congruentie:} Stel $x \sim_{\text{inf}} y$ dan bestaat de sequentie 
            \begin{equation*}
                x = x_0 \sim_0 x_1 \sim_1 \ldots \sim_{n-1} x_n = y
            \end{equation*}
            Aangezien elke $\sim_i$ rechts congruent is, geldt voor elke $a \in \Sigma$ dat 
            \begin{equation*}
                xa = x_0a \sim_0 x_1a \sim_1 \ldots \sim_{n-1} x_na = ya
            \end{equation*}
            Bijgevolg geldt dat $xa \sim_{\text{inf}} ya$ en dus dat $\sim_{\text{inf}}$ rechts congruent is.
        \item 
            \textbf{Verfijnen van $\sim_L$:} Stel $x \sim_{\text{inf}} y$ zodat er een sequentie bestaat 
            \begin{equation*}
                x = x_0 \sim_0 x_1 \sim_1 \ldots \sim_{n-1} x_n = y
            \end{equation*}
            Aangezien elke $\sim_i$ een verfijning is van $\sim_L$, geldt
            \begin{equation*}
                x_0 \in L \Leftrightarrow x_1 \in L \Leftrightarrow \ldots \Leftrightarrow x_n \in L
            \end{equation*}
            We bekomen $x \in L \Leftrightarrow y \in L$ en dus dat $\sim_{\text{inf}}$ een verfijning is van $\sim_L$.
    \end{itemize}
\end{prf}

\begin{pro}[MN(L) toebehorend aan een mininale DFA]{pro - MN(L) toebehorend aan een mininale DFA}
    Het kan nu ook bewezen worden dat de MN(L) relatie die hoort bij de minimale DFA voldoet aan de volgende conditie:
    \begin{equation*}
        x \sim_{\text{inf}} y \ \Leftrightarrow \  \forall s \in \Sigma^*: \ ( xs \in L \Leftrightarrow ys \in L )
    \end{equation*}
    Het is een vorm van $f$-gelijkheid gedefinieerd op strings in plaats van op toestanden.
\end{pro}

\begin{lem}[Stelling van Myhill-Nerode]{Stelling van Myhill-Nerode}
    Laat $L \subseteq \Sigma^*$ een taal zijn over $\Sigma$. De volgende drie uitspraken zijn dan equivalent:
    \begin{itemize}
        \item[$\Leftrightarrow$] $L$ is regulier
        \item[$\Leftrightarrow$] er bestaat een Myhill-Nerode relatie voor $L$
        \item[$\Leftrightarrow$] 
            definieer $\sim$ op $\Sigma^*$ als volgt:
            \begin{equation*}
                x \sim y \ \Leftrightarrow \ \forall s \in \Sigma^*: \ ( xs \in L \Leftrightarrow ys \in L );
            \end{equation*}
            de relatie $\sim$ heeft een eindige index
    \end{itemize}
    \vspace{-0.3cm}
\end{lem}   

\subsection{Pompend lemma voor reguliere talen}

\vspace{0.5cm}

\begin{lem}[Pompend lemma voor reguliere talen]{Pompend lemma voor reguliere talen}
    Voor een reguliere taal $L$ bestaan een pomplengte $d$, zodanig dat als $s \in L$ en $|s| \geq d$, 
    dan bestaat er een verdeling van $s$ in stukken $x$, $y$ en $z$ zodanig dat $s = xyz$ en \\
    \begin{minipage}{0.56\textwidth}
        \begin{itemize}
            \item $\forall i \in \mathbb{N}_0^+: \ xy^iz \in L$
            \item $|y| > 0$
            \item $|xy| \leq d$
        \end{itemize}
    \end{minipage}
    \begin{minipage}{0.4\textwidth}
       \hspace{1.25cm}\includegraphics[scale = 0.275]{Images/VerdelingStrings.png}
    \end{minipage}
    \vspace{-0.3cm}
\end{lem}

\begin{prf}[Pompend lemma voor reguliere talen]{prf - Pompend lemma voor reguliere talen}
    Neem een DFA die $L$ bepaalt, neem $d = \#Q$ en neem een willekeurige $s = a_1 \ldots a_n \in L$ met $n \geq d$.
    Beschouw de accepterende sequentie
    \begin{equation*}
        q_s = q_0 \overset{a_1}{\to} q_1 \overset{a_2}{\to} \ldots \overset{a_n}{\to} q_n \in F
    \end{equation*}
    Deze rij van toestanden heeft lengte $n+1$, wat strikt groter is dan $d$. Neem de eerste $d+1$ toestanden van de deze rij,
    dus $q_0,\ldots, q_d$. Er zijn maar $d$ verschillende toestanden, dus er zijn twee gelijke toestanden. 
    Stel dat $q_i = q_j$ met $ 0 \leq i < j \leq d$, dan nemen we $x = a_1 \ldots a_i$, $y = a_{i+1} \ldots a_j$ en $z$ de rest van de string. 
    Alles volgt nu direct, zie desnoods te illustratie in de stelling.
\end{prf}

\subsection{Varianten van eindige toestandsautomaten}

\vspace{0.5cm}

\begin{theo}[Transducer]{Transducer}
    \begin{minipage}{.66\textwidth}
        Een transducer zet een string om in een andere: we passen de definitie van een DFA een beetje aan, zodat ook output kan geproduceerd worden
        De labels zijn nu van de vorm $a/x$ waarbij $a$ in het inputalfabet zit en $x$ in een outputalfabet (inbegrepen de lege string). 
        Wat voor de $/$ staat wordt gebruikt om de weg te vinden in de transducer alsof het een DFA was. Wat na de $/$ staat wordt op de output gezet als die boog genomen wordt. 
        De transducer hiernaast accepteert elke string en geeft als output een 1 voor elke b die vlak na een a komt.
    \end{minipage}
    \begin{minipage}{.3\textwidth}
        \vspace{-0.3cm}\hspace{0.3cm}\includegraphics[scale = 0.3]{Images/Transducer.png}
    \end{minipage}
\end{theo}

\newpage

\begin{theo}[Optelchecker]{Optelchecker}
    \begin{minipage}{.75\textwidth}
        Een DFA kan alleen gebruikt worden om te beslissen of een string behoort tot een taal.
        Zo zou je kunnen een taal definiëren van strings die correcte optellingen voorstellen en als die taal regulier is er een DFA voor bouwen.
        Hier is een poging: $\Sigma = \{0,1\}$. De twee getallen  die we willen optellen en het resultaat komen in binair, omgekeerd en we maken ze even lang door bij de kortste(n) wat leidende nullen toe te voegen.
        Dus als we $3$ willen optellen bij $13$, met resultaat $16$, dan hebben we de drie bitstrings $11000$, $10110$ en $00001$. Die mengen we nu systematisch,
        t$.$t$.$z$.$ we maken groepjes van $3$ bits die op de i-de plaats voorkomen en schrijven die groepjes achter elkaar. Dus we hebben 
        \begin{equation*}
            110  \ 100 \ 010 \ 010 \ 001
        \end{equation*}
        waarbij de blanco’s enkel dienen om de groepering per drie te laten zien. Dus de string 
        \begin{equation*}
            110100010010001
        \end{equation*}
        stelt de correcte optelling 3+13=16 voor.
        Een DFA voor de taal van correcte optellingen staat in de figuur hiernaast.
    \end{minipage}
    \begin{minipage}{.21\textwidth}
        \vspace{-0.3cm}\includegraphics[scale = 0.35]{Images/Optelchecker.png}
    \end{minipage}
\end{theo}

\begin{theo}[Optel-transducer]{Optel-transducer}
    Optellen bestaat eigenlijk in: gegeven twee getallen als input, output de som. Dat kan met een transducer: gebruik dezelfde voorstelling van de twee getallen die je wil optellen als hiervoor, 
    en meng die op dezelfde manier, dus 3+13 wordt voorgesteld als de string
    \begin{equation*}
        1110010100.
    \end{equation*}
    \begin{center}
        \hspace{0.25cm}\includegraphics[scale = 0.45]{Images/OptelTranducers.png}
    \end{center}
\end{theo}

\newpage

\begin{theo}[Two-way finite automata]{Two-way finite automata}
    Een DFA staat ook wel gekend als een one-way finite automata, omdat de input van links naar rechts gelezen wordt en de automaat niet terug kan gaan.
    Een two-way finite automata 2DFA is een DFA die ook van rechts naar links kan lezen. De automaat kan dus terugkeren naar vorige toestanden.
    \vspace{-0.05cm}
\end{theo}

\begin{theo}[Büchi automaten]{Büchi automaten}
    Büchi automaten trekken op NFA's maar je geeft er geen eindige strings aan, wel oneindige lange: er is dus geen moment waarop je string eindigt bij het doorlopen.
    De oneindige string $s$ wordt aanvaard indien de rij toestanden waarlangs je passeert oneindig dikwijls een aanvaardende toestand heeft.
    \vspace{-0.05cm}
\end{theo}

\subsection{Contextvrije talen en hun grammatica}

\vspace{0.5cm}

\begin{theo}[Contextvrije grammatica - CFG]{Contextvrije grammatica - CFG}
    Een contextvrije grammatica is een 4-tal $(V, \Sigma, R, S)$ waarbij
    \begin{itemize}
        \item $V$ een eindige verzameling is van niet-eindsymbolen of \textbf{variabelen}
        \item $\Sigma$ een eindige alfabet is van eindsymbolen of \textbf{terminals}, disjunct met $V$
        \item $R$ is een eindige verzameling van regels of \textbf{producties}: een regel is een koppel van één niet-eindsymbool en een strings van elementen uit $V \cup \Sigma_{\epsilon}$. 
              We schrijven $u \to v$ voor een regel $(u,v)$.
        \item $S \in V$ is het \textbf{startsymbool}
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\begin{theo}[Afleiding m$.$b$.$v$.$ een CFG]{Afleiding m.b.v. een CFG}
    Gegeven een CFG $(V, \Sigma, R, S)$. Een string $f$ over $V \cup \Sigma_{\epsilon}$ wordt afgeleid uit een string $b$ over $V \cup \Sigma_{\epsilon}$ 
    m$.$b$.$v$.$ de CFG als er een eindige rij strings $s_0, \ldots, s_n$ bestaat zodanig dat
    \begin{itemize}
        \item $s_0 = b$
        \item $s_n = f$
        \item $\forall i \in [0,n-1]: \ s_i \to s_{i+1}$
    \end{itemize} 
    We noteren: $s_i \Rightarrow s_{i+1}$ en $b \Rightarrow^* f$. 
    \vspace{-0.1cm}
\end{theo}

\begin{theo}[Taal bepaald door een CFG]{Taal bepaald door een CFG}
    De taal $L_{\text{CFG}}$ bepaald door een CFG $(V, \Sigma, R, S)$ is de verzameling strings $s$ over $\Sigma$ zodanig dat $S \Rightarrow^* s$. In formulevorm:
    \begin{equation*}
        L = \{ w \in \Sigma^* \ | \ S \Rightarrow^* w \}
    \end{equation*}
    \vspace{-0.5cm}
\end{theo}

\newpage

\begin{theo}[Contextvrije taal - CFL]{Contextvrije taal - CFL}
    Een taal $L$ is \textbf{contextvrij} indien er een CFG bestaat die $L$ bepaalt, en dus $L = L_{\text{CFG}}$.
\end{theo}

\begin{theo}[Equivalente CFG's]{Equivalente CFG's}
    Twee contextvrije grammatica's CFG$_1$ en CFG$_2$ zijn \textbf{equivalent} als ze dezelfde taal bepalen, en dus $L_{\text{CFG}_1} = L_{\text{CFG}_2}$.
\end{theo}

\begin{theo}[Chomsky normaalvorm]{Chomsky normaalvorm}
    Een CFG $(V, \Sigma, R, S)$ heeft de \textbf{Chomsky normaalvorm} als elke regel één van de volgende vormen heeft:
    \begin{itemize}
        \item $A,B, \ C \in V: \ A \to BC$
        \item $A \in V, \ \alpha \in \Sigma: \ A \to \alpha$ 
        \item $S \to \epsilon$
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\begin{lem}[Equivalente Chomsky normaalvorm]{Equivalente Chomsky normaalvorm}
    Voor elke CFG $(V, \Sigma, R, S)$ bestaat er een equivalentie CFG in Chomsky normaalvorm.
\end{lem}

\newpage

\begin{prf}[Equivalente Chomsky normaalvorm]{prf - Equivalente Chomsky normaalvorm}
    We vertrekken van een willekeurige CFG en transformeren hem terwijl we equivalentie bewaren naar Chomsky Normaalvorm.
    \begin{enumerate}
        \item 
            Vervang alle voorkomens van $S$ door een nieuw symbool $X$, en daarna voeg de regel $S \to X$ toe. Zo komt $S$ enkel links voor.
            Zo wordt 1 van de voorwaarden voldaan. Deze stap is evident equivalentiebewarend.
        \item 
            Neem de verzameling van alle regels. Itereer de volgende operatie zo lang tot een fixpunt bereikt wordt:
            \begin{itemize}
                \item Selecteer een regel $A \to \epsilon$ en een regel $B \to \alpha A \beta$.
                \item Voeg de regel $B \to \alpha\beta$ toe.
            \end{itemize}
            Deze stap is equivalentiebewarend. Daarvoor moet aangetoond worden dat elke iteratie equivalentiebewarend is. Kortom,
            als $B \to \alpha A \beta$ toegevoegd wordt, dan kan een string geschreven worden met die regel als en slechts als de strings geschreven
            kan worden zonder deze regel. Het is evident omdat het herschrijven met $B \to \alpha\beta$ kan gesimuleerd worden met $B \to \alpha a \beta$ en $A \to \epsilon$.
            Tenslotte: verwijder alle regels $A \to \epsilon$ voor $A \neq S$. Ook deze stap is equivalentiebewarend. Neem een parsing boom
            $S \to \ldots$; de wortel is $S$, elke node is gelabeld met een symbool $A$, elke node die geen blad is eheft een geordende rij kinderen
            gelabeld $BC \ldots D$ zodat $A \to BC \ldots D$ een regel is, en de bladeren van de bomen vormen een sequentie van terminale symbolen. 
            Dan is het vrij duidelijk dat elke string van de CFL zo'n parsing boom heeft. Ook dat deze boom kan hervormd worden tot een boom
            die gebruik maakt van de toegevoegde regels en geen gebruik maakt van regels $A \to \epsilon$.
        \item
            Nu willen we afgeraken van de regels van de vorm $A \to B$. Voor een regel van de vorm $\mathcal{E} = A \to B$ en een regel van de vorm
            $\mathcal{R} = B \to \gamma$, definieer de regel $\mathcal{U}(\mathcal{E},\mathcal{R}) = A \to \gamma$. Zolang er regels van de vorm $\mathcal{E} = A \to B$ zijn (waaron $B$ ook een niet-terminal is)
            en regels van de vorm $\mathcal{R} = B \to \gamma$ zijn, voeg de regel $\mathcal{U}(\mathcal{E},\mathcal{R})$ toe. Nadat dit eindigt, verwijderen we uit de bekomen grammatica alle regels van de vorm $A \to B$.
            Deze stap is equivalentiebewarend. Neem een string $s$ die kan afgeleid worden met de regels van de vorm $A \to B$. Dan kan $s$ ook afgeleid worden zonder deze regels.
        \item 
            We hebben nu nog drie soorten regels te behandelen:
            \begin{enumerate}
                \item $A \to \gamma$ waar $\gamma$ uit juist twee niet-eindsymbolen bestaat.
                \item $A \to \gamma$ waar $\gamma$ uit minstens twee symbolen bevat: vervang elke terminal $a$ door een niet-terminaal $A_a$ en voeg de regel $A_a \to a$ toe.
                \item eventueel $S \to \epsilon$: die mag blijven.
            \end{enumerate}
        \item 
            De regels van de vorm 
            \begin{equation*}
                n > 2: A \to X_1X_2 \ldots X_n
            \end{equation*} 
            vervang je door
            \begin{equation*}
                A \to X_1Y_1, \ Y_1 \to X_2Y_2, \ldots, \ Y_{n-2} \to X_{n-1}X_n
            \end{equation*}
    \end{enumerate}
    Hierbij is het duidelijk dat bij de transformatie naar de Chomsky Normaalvorm de grammatica equivalent blijft.
\end{prf}

\subsection{Push-down automaat}

\vspace{0.5cm}

\begin{theo}[Aanvaarding van een string $s$ door een PDA]{Aanvaarding van een string s door een PDA}
    Een string $s$ wordt aanvaard door een PDA indien $s$ kan worden opgesplitst in delen $i \in [1,m]: \ w_i \in \Sigma_\epsilon$, er toestanden $j \in [0,n]: \ q_j$ zijn en 
    stacks $k \in [0,m]: \ \text{stack}_k \in \Gamma^*$, zodanig dat 
    \begin{itemize}
        \item $\text{stack}_0 = \epsilon$: de stack is leeg in het begin
        \item $q_0 = q_s$: we vertrekken in de begintoestand
        \item $q_m \in F$: we komen aan in een eindtoestand met een lege string
        \item $x,y \in \Gamma_\epsilon: \ (q_{i+1},y) \in \delta(q_i,w_{i+1},x)$ en $x,y \in \Gamma_\epsilon, \ t \in \Gamma^*: \ \text{stack}_i = xt, \ \text{stack}_{i+1} = yt$
        % \item $x,y \in \Gamma_\epsilon, \ t \in \Gamma^*: \ \text{stack}_i =
        % xt, \ \text{stack}_{i+1} = yt$.
    \end{itemize}  
    \vspace{-0.3cm}
\end{theo}

\begin{theo}[Taal bepaald door een PDA]{Taal bepaald door een PDA}
    \vspace{-0.1cm}
    De taal $L$ bepaald door een PDA bestaat uit alle strings die door de PDA
    aanvaard worden.
    \vspace{-0.1cm}
\end{theo}

\subsection{Equivalentie van CFG en PDA}

\vspace{0.5cm}

\begin{lem}[Equivalentie van CFG en PDA]{Equivalentie van CFG en PDA}
    \vspace{-0.1cm}
    Elke push-down automaat bepaalt een contextvrije taal en elke contextvrije taal wordt bepaald door een push-down automaat.
    \vspace{-0.1cm}
\end{lem}

\subsection{Pompend lemma voor contextvrije talen}

\vspace{0.5cm}

\begin{lem}[Pompend lemma voor contextvrije talen]{Pompend lemma voor contextvrije talen}
    \vspace{-0.1cm}
    Voor een contextvrije taal $L$ bestaan een getal $p$ (de pomplengte) zodanig dat elke string $s$ van $L$ met lengte
    strikt groter dan $p$ kan opgedeeld worden in $5$ stukken $u,v,x,y,z \in \Sigma^*$ zodanig dat $s = uvxyz$
    \begin{itemize}
        \item $\forall i \in \mathbb{N}_0^+: \ uv^ixy^iz \in L$
        \item $|vy| > 0$
        \item $|vxy| \leq p$
    \end{itemize}
    \vspace{-0.3cm}
\end{lem}

\begin{prf}[Pompend lemma voor contextvrije talen]{prf - Pompend lemma voor contextvrije talen}
    \vspace{-0.1cm}
    Als $L$ eindig is dan is de stelling triviaal voldaan. Immers, dan heeft $L$ een langste string $s$; 
    neem $p = |s|$. Dan zijn er geen strings met lengte strikt groter dan $p$, en
    dan is de stelling triviaal voldaan. \\ \vspace{-0.2cm} 
\end{prf}

