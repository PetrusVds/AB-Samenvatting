\subsection{Wat is een taal?}

\vspace{0.5cm}

\begin{theo}[String over een alfabet $\Sigma$]{String over een alfabet Sigma}
    Een \textbf{string} over een alfabet $\Sigma$ is een eindige opeenvolging van nul, één of meer elementen van $\Sigma$.
\end{theo}

\begin{app}[$\epsilon$-compressie van een string]{epsillon-compressie}
    Als we uit een string $w \in \Sigma_{\epsilon}$ elk voorkomen van $\epsilon$ schrappen, wat resulteert in een nieuwe string $s$, dan noemen we $s$ de $\epsilon$-compressie van $w$. 
\end{app}

\begin{theo}[Taal $L$ over een alfabet $\Sigma$]{Taal L over een alfabet Sigma}
    Een \textbf{taal} $L$ over een alfabet $\Sigma$ is een verzameling van strings over $\Sigma$.
\end{theo}

\subsection{Een algebra van talen}

\vspace{0.5cm}

\begin{theo}[Een algebra- of algebraïsche structuur]{Een algebra- of algebraïsche structuur}
    Een algebra- of algebraïsche structuur is een verzameling met daarop een aantal inwendige operaties: dikwijls binaire operaties, maar unair of met grotere ariteit kan ook. Zo wordt de verzameling van alle talen over een alfabet $\Sigma$ een algebra als we als operaties unie, doorsnede, complement, etc.\ definïeren. Meer concreet: als $L_1$ en $L_2$ twee talen zijn, dan is
    \begin{itemize}
        \item de unie ervan een taal: $L_1 \cup L_2$
        \item de doorsnede ervan een taal: $L_1 \cap L_2$
        \item het complement ervan een taal: $\overline{L_1}$
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\begin{pro}[Concatenatie van twee talen]{Concatenatie van twee talen}
    Gegeven twee talen $L_1$ en $L_2$ over hetzelfde alfabet $\Sigma$, dan noteren we de concatenatie van
    $L_1$ en $L_2$ als $L_1L_2$ en definïeren we:
    \begin{equation*}
        L_{1}L_{2} = \{ xy  \ | \ x \in L_1,  \ y \in L_2\}
    \end{equation*}
    \vspace{-0.5cm}
\end{pro}

\newpage

\begin{pro}[Kleene ster van een taal]{Kleene ster van een taa}
    De Kleene ster van een taal wordt gedefinieerd als volgt:
    \begin{equation*}
        L^* = \cup_{n \geq 0}L^n
    \end{equation*}
    \vspace{0.3cm}
    \textbf{Opmerking:} $L^+ = LL^*$
    \vspace{-0.3cm}
\end{pro}

\begin{app}[Kleene ster van een alfabet]{Kleene ster van een alfabet}
    De verzameling van alle strings over een alfabet $\Sigma$ is de kleene ster van het aflabet $\Sigma^*$, en volgt dus dat
    \begin{equation*}
        L \in \mathcal{P}(\Sigma^*)
    \end{equation*}
    \vspace{-0.5cm}
\end{app}

\subsection{Reguliere expressies en reguliere talen}

\vspace{0.5cm}

\begin{theo}[Reguliere Expressie (RE) over een alfabet $\Sigma$]{Reguliere Expressie (RE) over een alfabet Sigma}
    E is een \textbf{reguliere expressie} over een alfabet $\Sigma$ indien E van de vorm is
    \begin{itemize}
        \item $\epsilon$
        \item $\phi$
        \item $a$ waarbij $a \in \Sigma$
        \item ($E_{1}E_{2}$) waarbij $E_1$ en $E_2$ reguliere expressies zijn over $\Sigma$
        \item ($E_{1}^*$) waarbij $E_1$ een reguliere expressies is over $\Sigma$
        \item ($E_{1}|E_{2}$) waarbij $E_1$ en $E_2$ reguliere expressies zijn over $\Sigma$
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\begin{theo}[Reguliere taal]{Reguliere taal}
    Een reguliere expressie $E$ bepaalt een \textbf{reguliere taal} $L_E$ over hetzelfde alfabet $\Sigma$ als volgt:
    \begin{itemize}
        \item als $E = a \ (\text{met} \ a \in \Sigma)$ dan is $L_E = \{a\}$
        \item als $E = \epsilon$ dan is $L_E = \{\epsilon\}$
        \item als $E = \phi$ dan is $L_E = \emptyset$
        \item als $E = (E_{1}E_{2})$ dan $L_E = L_{E_1}L_{E_2}$
        \item als $E = {(E_{1})}^{*}$ dan $L_E = L_{E_1}^*$
        \item als $E = (E_{1}|E_{2})$ dan $L_E = L_{E_1} \cup L_{E_2}$
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\newpage

\subsection{Niet-deterministische eindge toestandsautomaten}

\vspace{0.5cm}

\begin{theo}[Niet-deterministische eindige toestandsautomaat (NFA)]{Niet-deterministische eindige toestandsautomaat}
    Een \textbf{niet-deterministische eindige toestandsautomaat} is een 5-tal $(Q,\Sigma, \delta, q_s, F)$ waarbij

    \vspace{0.5cm}

    \begin{minipage}{.61\textwidth}
        \begin{itemize}
            \item $Q$ een eindige verzameling toestanden is
            \item $\Sigma$ is een eindig alfabet
            \item $\delta \subseteq Q \times \Sigma_{\epsilon} \times Q$ is de overgangsrelatie van de automaat, wat kan worden voorgesteld in een transitietabel
            \item $q_s$ is de starttoestand
            \item $F \subseteq Q$ is de verzameling eindtoestanden
        \end{itemize}
    \end{minipage}
    \hspace{0.3cm}
    \begin{minipage}{.35\textwidth}
        \begin{center}
            \includegraphics[scale = 0.25]{Images/NFA}
        \end{center}
    \end{minipage}

    \vspace{0.5cm}

    \textbf{Opmerking:} In de literatuur wordt $\delta$ soms ook als een functie gedefinieerd die een toestand en een symbool afbeeldt op de verzameling van toestanden waarnaar een overgang mogelijk is:
    \begin{equation*}
        \delta(q,a) = \{ q' \in Q \ | \ (q,a,q') \in \delta \}.
    \end{equation*}
    We schrijven $p \overset{a}{\longrightarrow} q$ om aan te geven dat $(p,a,q)$ een overgang is in $\delta$.
    % \vspace{-0.3cm}
\end{theo}
    
\begin{theo}[Aanvaarden van strings in een NFA]{Aanvaarden van strings in een NFA}
    Een string $s$ wordt aanvaard door een NFA $(Q,\Sigma, \delta, q_s, F)$ indien
    er een sequentie $q_s = q_0 \overset{a_0}{\longrightarrow} \ldots \overset{a_{n-1}}{\longrightarrow} q_n$
    van overgangen bestaat met $q_n \in F$ zodat s de $\epsilon$-compressie is van $a_0 \ldots a_{n-1}$. \\
    
    \noindent \textbf{Dus:} Voor toestanden $p$,$q$ en string $w \in \Sigma^*$ schrijven we $p \overset{w}{\rightsquigarrow} q$
    indien er een sequentie van overangen $ p \overset{a_0}{\longrightarrow} \ldots \overset{a_{n-1}}{\longrightarrow} q$ bestaat zodat $w$
    de $\epsilon$-compressie is van $a_0 \ldots a_{n-1}$.
\end{theo}

\begin{theo}[Taal $L$ bepaald door een NFA $M$]{Taal L bepaald door een NFA M}
    Een taal $L$ wordt bepaald door een NFA $M$, indien $L$ de verzameling van strings is die $M$ aanvaardt.
    We noteren de taal van $M$ als $L_M$.
\end{theo}

\begin{theo}[Equivalentie van twee NFA's]{Equivalentie van twee NFA's}
    Twee NFA's worden \textbf{equivalent} genoemd als ze dezelfde taal bepalen, m$.$a$.$w$.$ elke equivalentieklassen van deze equivalentierelatie komt overeen met een taal.
\end{theo}

\newpage

\subsection{De algebra van NFA's}

\vspace{0.5cm}

\begin{pro}[Unie van twee NFA's]{Unie van twee NFA's}
    \underline{Gegeven}: $i \in \{1,2\}: \ \text{NFA}_i = (Q_i,\Sigma, \delta_i, q_{s_i}, \{q_{f_i}\})$ \\
    
    % $\text{NFA}_1 = (Q_1,\Sigma, \delta_1, q_{s_1}, \{q_{f_1}\})$ en $\text{NFA}_2 = (Q_2,\Sigma, \delta_2, q_{s_2}, \{q_{f_2}\})$ \\

    \begin{minipage}{.6\textwidth}
        De unie $\text{NFA}_1 \cup \text{NFA}_2$ is de $\text{NFA} = (Q,\Sigma, \delta, q_s, F)$ waarbij 
        \begin{itemize}
            \item $Q = Q_1 \cup Q_2 \cup \{ q_s, q_f \}$, $F = \{q_f\}$
            \item $\delta$  is gedefnieerd als:
            \begin{itemize}
                \item $\forall x \in \Sigma: \delta(q_s, x) = \emptyset \ \land \ \delta(q_{f_{i}}, x) = \emptyset$
                % \item $\forall x \in \Sigma: \delta(q_{f_{i}}, x) = \emptyset$
                \item $\forall q \in Q_{i} \backslash \{q_{f_{i}}\}, \ x \in \Sigma_{\epsilon}: \ \delta(q,x) = \delta_i(q,x)$
                \item $\delta(q_s, \epsilon) = \{q_{s_{1}}, q_{s_{2}}\}$
                \item $\delta(q_{f_{i}}, \epsilon) = \{q_f\}$
            \end{itemize}
        \end{itemize}
    \end{minipage}
    % \hspace{-0.5cm}
    \begin{minipage}{.36\textwidth}
        \includegraphics[scale = 0.225]{Images/UnieNFA}
    \end{minipage}
\end{pro}

\begin{pro}[Concatenatie van twee NFA's]{Concatenatie van twee NFA's}
    \underline{Gegeven}: $i \in \{1,2\}: \ \text{NFA}_i = (Q_i,\Sigma, \delta_i, q_{s_i}, \{q_{f_i}\})$ \\

    De concatenatie $\text{NFA}_1\text{NFA}_2$ is de $\text{NFA} = (Q,\Sigma, \delta, q_s, F)$ waarbij \\

    \vspace{-0.2cm}
    \begin{minipage}{.6\textwidth}
        \begin{itemize}
            \item $Q = Q_1 \cup Q_2$, $q_s = q_{s_1}$, $F = \{q_{f_2}\}$
            \item 
                $\delta$ is gedefnieerd als:
                \begin{itemize}
                    \item $\forall x \in \Sigma: \ \delta{q_{f_1}, x} = \emptyset$
                    \item $\forall q \in Q_{i}\backslash \{q_{f_1}\}, \ x \in \Sigma_{\epsilon}: \ \delta(q,x) = \delta_i(q,x)$
                    \item $\delta(q_{f_1}, \epsilon) = \{q_{s_2}\}$
                \end{itemize}
        \end{itemize}
        % \begin{itemize}
        %     \item $Q = Q_1 \cup Q_2 \cup \{ q_s, q_f \}$
        %     \item $F = \{q_f\}$
        %     \item $\delta$ is gedefnieerd als:
        %     \begin{itemize}
        %         \item $\forall q \in Q_{i} \backslash \{q_{f_{i}}\}, \ x \in \Sigma_{\epsilon}, \ i = 1,2: \ \delta(q,x) = \delta_i(q,x)$
        %         \item $\delta(q_s, \epsilon) = \{q_{s_{1}}, q_{s_{2}}\}$
        %         \item $\forall x \in \Sigma: \delta(q_s, x) = \emptyset$
        %         \item $i = 1,2: \delta(q_{f_{i}}, \epsilon) = \{q_f\}$
        %         \item $\forall x \in \Sigma, i = 1,2: \delta(q_{f_{i}}, x) = \emptyset$
        %     \end{itemize}
        % \end{itemize}
    \end{minipage}
    \hspace{-0.5cm}
    \begin{minipage}{.36\textwidth}
        \includegraphics[scale = 0.28]{Images/ConcatNFA}
    \end{minipage}
    % \begin{center}
    %     \includegraphics[scale = 0.35]{Images/ConcatNFA}
    % \end{center}
\end{pro}

\begin{pro}[Kleene ster van een NFA]{Kleene ster van een NFA}
    \underline{Gegeven}: $\text{NFA}_1 = (Q_1,\Sigma, \delta_1, q_{s_1}, \{q_{f_1}\})$ \\

    De Kleene ster $\text{NFA}_1^*$ is de NFA $= (Q,\Sigma, \delta, q_s, F)$ waarbij \\

    \vspace{-0.1cm}
    \begin{minipage}{.56\textwidth}
        \begin{itemize}
            \item $Q = Q_1 \cup \{q_s, q_f\}$, $F = \{q_f\}$
            \item 
                $\delta$ is gedefnieerd als:
                \begin{itemize}
                    \item $\forall x \in \Sigma: \delta(q_{s}, x) = \emptyset \ \land \ \delta(q_{f_1}, x) = \emptyset$
                    % \item $\forall x \in \Sigma: \delta(q_{s}, x) = \emptyset$
                    \item $\forall q \in Q_{1}\backslash \{q_{f_1}\}, \ x \in \Sigma_{\epsilon}: \ \delta(q,x) = \delta_1(q,x)$
                    \item $\delta(q_s, \epsilon) = \{q_{s_1}, q_{f_1}\}$
                    \item $\delta(q_{f_1}, \epsilon) = \{q_{s}, q_{f}\}$
                \end{itemize}
        \end{itemize}
        % \begin{itemize}
        %     \item $Q = Q_1 \cup Q_2 \cup \{ q_s, q_f \}$
        %     \item $F = \{q_f\}$
        %     \item $\delta$ is gedefnieerd als:
        %     \begin{itemize}
        %         \item $\forall q \in Q_{i} \backslash \{q_{f_{i}}\}, \ x \in \Sigma_{\epsilon}, \ i = 1,2: \ \delta(q,x) = \delta_i(q,x)$
        %         \item $\delta(q_s, \epsilon) = \{q_{s_{1}}, q_{s_{2}}\}$
        %         \item $\forall x \in \Sigma: \delta(q_s, x) = \emptyset$
        %         \item $i = 1,2: \delta(q_{f_{i}}, \epsilon) = \{q_f\}$
        %         \item $\forall x \in \Sigma, i = 1,2: \delta(q_{f_{i}}, x) = \emptyset$
        %     \end{itemize}
        % \end{itemize}
    \end{minipage}
    % \hspace{-0.1cm}
    \begin{minipage}{.4\textwidth}
        \includegraphics[scale = 0.325]{Images/SterNFA}
    \end{minipage}
    % \begin{center}
    %     \includegraphics[scale = 0.4]{Images/SterNFA}
    % \end{center}
\end{pro}

\subsection{Van RE naar NFA}

\vspace{0.5cm}

\begin{theo}[RE $\to$ NFA]{RE naar NFA}
    We hebben alle ingrediënten om van een reguliere expressie RE een NFA te maken, en zodanig dat de $L_{RE} = L_{NFA}$.
    Vermits reguliere expressies inductief gedefinieerd zijn zullen we voor elk lijntje van die definitie een overeenkomstige NFA definiëren.
    De drie basisgevallen $\epsilon$, $\phi$ en $a \in \Sigma$ zijn triviaal te modeleren als NFA.
    We illusteren hieronder:
    \begin{center}
        \includegraphics[scale = 0.275]{Images/NFABasisGevallen.png}
    \end{center}
    De drie recursieve gevallen beschrijven we als volgt: laat $E_{1}$ en $E_{2}$ twee reguliere expressies zijn, dan is
    \begin{itemize}
        \item $NFA_{E_{1}E_{2}} = \text{concat}(NFA_{E_{1}},NFA_{E_{2}})$
        \item $NFA_{E_{1}^{*}} = \text{ster}(NFA_{E_{1}})$
        \item $NFA_{E_{1}|E_{2}} = \text{unie}(NFA_{E_{1}},NFA_{E_{2}})$
    \end{itemize}
    \noindent De constructie hierboven bewaart de taal, t.t.z. $L_{NFA_{E}} = L_{E}$.
\end{theo}

\subsection{Van NFA naar RE}

\vspace{0.5cm}

\begin{theo}[GNFA]{GNFA}
    Een \textbf{GNFA} is een eindige toestandsmachine met de volgende wijzigingen en beperkingen: \\

    % \begin{itemize}
    %     \item er is slechts één eindtoestand en die is verschillend van de starttoestand
    %     \item vanuit de starttoestand vertrekt er juist één boog naar elke andere toestand; er komen geen bogen aan in de starttoestand
    %     \item in de eindtoestand komt juist één boog aan vanuit elke andere toestand; uit de eindtoestand vertrekken geen bogen
    %     \item voor paar \(p\),\(q\) (let op: p = q is geldig) van andere toestanden (geen start- of eindtoestand) is er juist één boog van \(p \to q\) en één boog van \(q \to p\).
    %     \item  de bogen hebben als label een reguliere expressie
    % \end{itemize} 
    \begin{minipage}{.56\textwidth}
        \begin{itemize}
            \item er is slechts één eindtoestand en die is verschillend van de starttoestand
            \item vanuit de starttoestand vertrekt er juist één boog naar elke andere toestand; er komen geen bogen aan in de starttoestand
            \item in de eindtoestand komt juist één boog aan vanuit elke andere toestand; uit de eindtoestand vertrekken geen bogen
            \item voor paar \(p\),\(q\) (let op: \(p\) = \(q\) is geldig) van andere toestanden (geen start- of eindtoestand) is er juist één boog \(p \longrightarrow q\) en één boog \(q \longrightarrow p\).
            \item  de bogen hebben als label een reguliere expressie
        \end{itemize} 
    \end{minipage}
    \hspace{0.1cm}
    \begin{minipage}{.4\textwidth}
        \includegraphics[scale = 0.35]{Images/GNFA.png}
    \end{minipage}
\end{theo}

\newpage

\begin{alg}[NFA $\to$ RE]{NFA naar RE}
    \begin{enumerate}
        \item Maak van de NFA een GNFA
        \begin{itemize}
            \item Behoud alle toestanden en bogen van de NFA
            \item Als er meerdere bogen zijn tussen twee toestanden gelabeld met symbolen \(a_{1} \ldots a_{n} \) vervang deze door één boog met als label \(a_{1} | \ldots | a_{n} \)
            \item Voer een nieuwe starttoestand in en een \(\epsilon\)-boog naar de oude starttoestand
            \item Voer een nieuwe eindtoestand in en \(\epsilon\)-bogen vanuit elke oude eindtoestand
            \item Voor elke boog die ontbreekt tussen twee toestanden om een GNFA te bekomen, voer een \(\phi\)-boog in
        \end{itemize}
        \item Reduceer de GNFA: \vspace{0.3cm} \\
            % \begin{minipage}{.453\textwidth} 
                Kies een willekeurige toestand \(X\) verschillend van de start- of eindtoestand, ga naar stap 3 als dit niet mogelijk is.
                Voor elk paar toestanden \(A\) en \(B\) (let op: \(A\) = \(B\) is geldig) verschillend van X bevat de GNFA een unieke boog \(A \to B\) met label \(E_{4}\), 
                \(A \to X\) met label \(E_{1}\), \(X \to X\) met label \(E_{2}\) en \(X \to B\) met label \(E_{3}\). Vervang het label op de boog \(A \to B\) door \(E_{4} | E_{1}E_{2}^{*}E_{3}\).
                Doe dit voor alle keuzes voor A en B. Verwijder daarna de knoop X en herhaal.
            % \end{minipage}
            % \begin{minipage}{.43\textwidth}
            %     \hspace{0.3cm}\includegraphics[scale = 0.375]{Images/GNFAToestandVerwijderen}
            % \end{minipage}
                \begin{center}
                    \includegraphics[scale = 0.375]{Images/GNFAToestandVerwijderen}
                \end{center}
        \item Bepaal RE: de boog van de GNFA heeft als label de gezochte RE
    \end{enumerate}
\end{alg}

\begin{lem}[Taal herkend door een NFA]{Taal herkend door een NFA}
    De taal herkend door de NFA is de taal van de berekende reguliere expressie, en dus bepalen de twee geziene formalismen NFA en RE precies dezlfde klasse van talen: de reguliere talen.
\end{lem}   

\subsection{Deterministische eindige toestandsmachines}

\vspace{0.5cm}

\begin{theo}[Deterministische eindige toestandsmachines]{Deterministische eindige toestandsmachines}
    Een NFA is een DFA indien \(\delta\) geen \(\epsilon\)-overgangen bevat en 
    indien voor elke \(p \in Q\) en elke \(a \in \Sigma\) een unieke \(q \in Q\) 
    bestaat zodat \(p \overset{a}{\longrightarrow} q\). Het komt erop neer dat in een DFA, \(\delta\) 
    een totale functie $Q \times \Sigma \to Q$ is. Voor DFA's zullen a
    we de unieke toestand q zodat \(p \overset{a}{\longrightarrow} q\) dan ook noteren als \(\delta(p,a)\).
\end{theo}

\newpage

\begin{alg}[NFA $\to$ DFA]{NFA naar DFA}
    \vspace{-0.2cm}
    Neem voor een willekeurige string $w \in \Sigma^*$ de verzameling $\{ q \ | \ q_s \overset{w}{\rightsquigarrow} q\}$ van toestanden vereikbaar met $w$. We noteren deze verzameling als $q_w'$. Deze verzameling dient in een DFA een singleton te zijn, dit sugereert de volgende werkwijze: we bouwen een nieuwe automaat $(Q', \Sigma,\delta',q_s',F')$ waarvan de toestandenovereenkomen met verzamelingen van toestanden van de NFA\@. We construeren die zodanig dat voor elke string $w$ geldt dat $q_s' \overset{w}{\rightsquigarrow} q_w'$ (in de DFA), i\@.e\@. $q_w'$ is de set van toestanden in de NFA die bereikbaar zijn vanaf de oorspronkelijke begintoestand $q_s$ met $w$.  We definiëren:
    \begin{itemize}
        \item 
            $Q'$ als de verzameling van alle deelverzamelingen $q'$ van $Q$ die gesloten zijn onder $\epsilon$-bogen, dus
            \begin{equation*}
                p \in q' \ \land \ p \overset{\epsilon}{\longrightarrow} q \ \Rightarrow \ q \in q'
            \end{equation*}
        \item 
            $\delta': Q' \times \Sigma \rightarrow Q'$ als 
                \begin{equation*}
                    \delta'(q',a) = \{q \ | \ \exists p \in q': \ p \overset{a}{\rightsquigarrow} q \}
                \end{equation*}
        \item 
            $q_s'$ als de verzameling van $q_s$ en toestanden die bereikbaar zijn vanuit $q_s$ met $\epsilon$-bogen, dus
            \begin{equation*}
                q_s' = \{q_s,q \ | \ q_s \overset{\epsilon}{\rightsquigarrow} q \}
            \end{equation*}
        \item 
            $F'$ als de verzameling van alle $q'$ zodat $q' \cap F \neq \emptyset$, dus
            \begin{equation*}
                F' = \{q' \in Q' \ | \ q' \cap F \neq \emptyset \}
            \end{equation*}
    \end{itemize}
    Uit constructie volgt dat deze automaat $(Q', \Sigma,\delta',q_s',F')$ een DFA is.
\end{alg}

\begin{lem}[DFA en NFA equivalentie]{DFA en NFA equivalentie}
    De geconstrueerde DFA $(Q', \Sigma,\delta',q_s',F')$ is equivalent met de NFA $(Q, \Sigma, \delta, q_s, F)$. 
\end{lem}

\begin{prf}[DFA en NFA equivalentie]{prf - DFA en NFA equivalentie}
    We moeten verifiëren dat 
    \begin{equation*}
        \forall w \in \Sigma^*: \ q_s' \overset{w}{\rightsquigarrow} F' \ \Leftrightarrow \ q_s \overset{w}{\rightsquigarrow} F
    \end{equation*}
    De essentie van dat bewijs is dat 
    \begin{equation*}
        \forall w \in \Sigma^*: \ q_s' \overset{w}{\rightsquigarrow} q' \ \text{(in de DFA)} \ \ \Leftrightarrow \ q' = q_w = \{q \ | \ q_s \overset{w}{\rightsquigarrow} q\} \ \text{(in de NFA)} \
    \end{equation*}
     Dit is eenvoudig inductief te bewijzen gebruik makend van het feit dat $q' = q_w' \Rightarrow \delta'(q',a) = q_{wa}'$. Dan geldt dat de DFA een string $w$ aanvaardt als voor de unieke toestand $q'$ zodat $q_s' \overset{w}{\rightsquigarrow} q'$ geldt dat $q' \cap F \neq \emptyset \ \Leftrightarrow \ q_w' \cap F \neq \emptyset \ \Leftrightarrow \ q_s \overset{w}{\rightsquigarrow} F$.
\end{prf}

\begin{lem}[Taal bepaald door een DFA]{Taal herkend door een DFA}
    De taal bepaald door een DFA is een reguliere taal.
\end{lem}  

\newpage

\begin{pro}[Doorsnede, verschil en complement van DFA's]{Doorsnede, verschil en complement van DFA's}
    \underline{Gegeven}: $i \in \{1,2\}: \ {\text{DFA}}_i = (Q_i,\Sigma, \delta_i, q_{s_i}, \{q_{f_i}\})$ \\

    We maken een generische product DFA $(Q,\Sigma, \delta, q_s, F)$ als volgt:
    \begin{itemize}
        \item $Q = Q_1 \times Q_2$
        \item $\delta(p \times q, x) = \delta_1(p,x) \times \delta_2(q,x)$
        \item $q_s = (q_{s_1},q_{s_2})$
        \item 
            Om tot een volledig definitie te komen, moeten we nog $F$ bepalen:
            \begin{itemize}
                \item $F = F_1 \times F_2$: de DFA is de doorsnede van de twee talen
                \item $F = (F_1 \times Q_2) \cup (Q_1 \times F_2)$: de DFA is nu de unie van de twee talen
                \item $\forall i \neq j \in [1,2]: \ F =  F_i \times (Q_j \times F_j)$: de DFA bepaalt nu de strings die tot $L_i$ behoren, maar niet tot $L_j$
                \item $F = (Q_1 \backslash F_1) \times (Q_2 \backslash F_2)$: de DFA bepaalt nu de strings die tot geen van beide talen behoren.
            \end{itemize}
    \end{itemize}
    Hieruit volgt ook dat de unie, doorsnede en complement van twee reguliere talen ook regulier zijn. Daaruit volgt ook dat het
    complement van een reguliere taal ook regulier is, want $\overline{L} = \Sigma^* \backslash L$.
\end{pro}

% \begin{lem}[DFA en NFA equivalentie]{DFA en NFA equivalentie}
%     Elke NFA is equivalent met een DFA, m$.$a$.$w$.$ we kunnen elke NFA \((Q, \Sigma, \delta, q_s, F)\) herleiden tot een
%     equivalente DFA \((Q', \Sigma, \delta', q_s', F')\) waarbij
%     \begin{itemize}
%         \item \(Q'\): de verzameling van alle deelverzamelingen $q'$ van $Q$ die gesloten zijn onder \(\epsilon\)-bogen, dus
%               \(p \in q' \ \wedge \ p \overset{\epsilon}{\to} q \ \Rightarrow \ q \in q'\)
%         \item \(\delta': Q' \times \Sigma \rightarrow Q'\)
%         \item \(q_{s}' = \{q_s,q \ | \ q_s \overset{\epsilon}{\rightsquigarrow} q \}\)
%         \item \(F' = \{q' \in Q' \ | \ q' \cap F \neq \emptyset \}\)
%     \end{itemize}
%     \vspace{-0.3cm}
% \end{lem}

% \begin{prf}[DFA en NFA equivalentie]{prf - DFA en NFA equivalentie}
%     Uit constructie volgt dat de geconstrueerde automaat \((Q', \Sigma, \delta', q_s', F')\) een DFA is.
%     Wat betreft equivalentie, moeten we verifiëren dat \(\forall w \in \Sigma^*:  q_s \overset{w}{\rightsquigarrow} F \Leftrightarrow q_s' \overset{w}{\rightsquigarrow} F'\). 
%     De essentie van dat bewijs is dat voor elke \(w \in \Sigma^*\), als in de DFA geldt dat \(q_s' \overset{w}{\rightsquigarrow} q\) (in de DFA) dan is \(q\ = q_w = \{ q \ | \ q_s \overset{w}{\rightsquigarrow} q \}\) (in de NFA).
%     Dit is eenvoudig inductief te bewijzen gebruik makend van het feit dat \(q' = q_w' \Rightarrow \delta'(q',a) = q_{wa}'\). Dan geldt dat de 
%     DFA een string $w$ aanvaardt als voor de unieke toestand \(q'\) zodat \(q_s' \overset{w}{\rightsquigarrow} q'\) geldt dat \(q' \cap F \neq \emptyset \ \Leftrightarrow \ q_w' \cap F \neq \emptyset \ \Leftrightarrow\) de NFA aanvaardt w.
% \end{prf}

\begin{theo}[$f$-string]{f-string}
    We noemen een string $s$ een $f$-string vanuit $q$ van de DFA indien \(\delta^*(q,s) \in F\), t$.$t$.$z$.$ indien er een pad is van $q$ naar een toestand van $F$ die s genereert. $F$-gelijke toestanden
    zijn dan toestanden met dezelfde $f$-strings. \vspace{0.3cm}\\
    \textbf{Opmerking:} \(q \in F \Leftrightarrow \epsilon \text{ is een $f$-string vanuit $q$}\)
\end{theo}

\begin{theo}[$f$-gelijk]{f-gelijk}
    Twee toestanden \(q_1,q_2\) zijn $f$-gelijk indien
    \begin{equation*}
        \{ s \in \Sigma^* \ | \ \delta^*(q_1,s) \in F\} = \{s \in \Sigma^* \ | \ \delta^*(q_2,s) \in F\}
    \end{equation*}
    In woorden, als $q_1$ en $q_2$ exact dezelfde $f$-strings hebben.
\end{theo}

\begin{pro}[$f$-gelijk]{pro - f-gelijk}
    \begin{itemize}
        \item De relatie $f$-gelijk is een equivalentie-relatie.
        \item Als $p,q$ $f$-gelijk zijn dan geldt voor elk symbool $a$ dat \(\delta(p,a)\) en \(\delta(q,a)\) ook $f$-gelijk zijn.
        \item Als $p,q$ $f$-gelijk zijn dan geldt \(p \in F \Leftrightarrow q \in F\).
    \end{itemize}
\end{pro}

\begin{prf}[Eigenschappen van de $f$-gelijk relatie]{prf - Eigenschappen van de f-gelijk relatie}
    \begin{itemize}
        \item Het is triviaal om te bewijzen dat $f$-gelijkheid een equivalentie-relatie is. Dit kan je doen door de reflexiviteit, symmetrie en transitiviteit van de relatie na te gaan.
        \item Veronderstel dat $p,q$ $f$-gelijk zijn en veronderstel voor een willekeurig symbool $a$ dat \(\delta(p,a) = p', \delta(q,a) = q'\). De $f$-strings van $p$ en $q$ zijn gelijk,
              en dus ook hun $f$-strings van de vorm $as$. De $f$-strings van $p'$ zijn de strings $s$ zodat $as$ een $f$-string is van $p$.
              Hetzelfde geldt voor $q'$. Bijgevolg hebben $p',q'$ dezelfde $f$-strings en zijn ze dus $f$-gelijk.
        \item Als $p$ en $q$ $f$-gelijk zijn, en $p \in F$ dan is $\epsilon$ een $f$-string van $p$ en dus ook van $q$. Aangezien er in een DFA geen $\epsilon$-bogen zijn, is $q \in F$.
              Hetzelfde geldt in de andere richting. 
    \end{itemize}
    \vspace{-0.3cm}
\end{prf}

\begin{theo}[Minimale DFA]{Minimale DFA}
    De minimale DFA is de DFA met het minimale aantal toestanden die dezelfde taal bepaalt als de oorspronkelijke DFA\@. Als we vertrekken van een DFA $(Q,\Sigma, \delta, q_s, F)$, dan bestaat de minimale DFA uit $(\tilde{Q},\Sigma, \tilde{\delta}, \tilde{q_s}, \tilde{F})$ waarbij
    \begin{itemize}
        \item $\tilde{Q} = \{Q_1, \ldots, Q_n\}$ waarbij de $Q_i$ de equivalentie-klasse is van de relatie $f$-gelijk
        \item $\tilde{\delta}(Q_i,a) = Q_j$ indien een $q \in Q_i$ bestaat zodat $\delta(q,a) \in Q_j$
        \item $\tilde{q_s}$ is de equivalentie-klasse $Q_i$ zodat $q_s \in Q_i$
        \item $\tilde{F}$ is de verzameling van $Q_i$ waarvoor geldt dat $Q_i \subseteq F$. 
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\begin{lem}[DFA$_{\text{min}}$]{minDFA}
    Een DFA$_{\text{min}}$ is een DFA, equivalent met DFA, en alle toestanden zijn $f$-verschillend.
\end{lem}

\begin{prf}[DFA$_{\text{min}}$]{prf - minDFA}
    DFA$_{\text{min}}$ is een DFA omdat $f$-gelijkheid van toestanden $p$ en $q$ de $f$-gelijkheid van \(\delta(p,a)\) en \(\delta(q,a)\) impliceert. Het gevolg is dat verschillende bogen met hetzelfde symbool
    vanuit $f$-gelijke $p$ en $q$ versmelten. Om aan te tonen dat DFA en DFA$_{\text{min}}$ equivalent zijn, is de essentiële eigenschap dat elke equivalentie-klasse $Q_i$ en elk element \(p \in Q_i\)
    dezelfde $f$-strings heeft. Dus heeft $\tilde{q}_s$ dezelfde $f$-strings als $q_s$, en deze verzameling is dus de taal die beide DFA's bepalen. Aantonen dat een string $w$ een $f$-string is van $Q_i$
    als en slechts als $w$ een $f$-string is van \(q \in Q_i\) gebeurt door inductie op de lengte van $w$, gebruikmakend van het feit dat voor elke \(Q_i,Q_j\)
    \begin{equation*}
        p \in Q_i, \ q \in Q_j, \ \forall a \in \Sigma: \ Q_i \overset{a}{\longrightarrow} Q_j \ \Leftrightarrow \ p \overset{a}{\longrightarrow} q 
    \end{equation*}
    Tenslotte, twee verschillende toestanden $Q_i, Q_j$ bevatten $f$-verschillende toestanden. Aangezien de $f$-strings van $Q_i$ en $Q_j$ die van hun elementen zijn, zijn ze $f$-verschillend.
\end{prf}

\newpage

\begin{alg}[DFA $\to$ DFA$_\text{min}$]{DFA naar minDFA}
    We gaan ervoor zorgen dat de alle toestanden van de DFA $f$-verschillend zijn, ofwel alle $f$-gelijke toestanden samenvoegen tot één toestand. We beginnen uit $Q^2$: dit komt neer op de veronderstelling dat alle paren $f$-gelijk zijn. In eerste instantie schrappen we koppels $(p,q)$ waarvan ofwel $p$ ofwel $q$ behoort tot $F$ maar niet allebei want deze koppels worden uitgesloten door de `enkel als' regel. Zij zijn zeker niet $f$-gelijk aangezien 1 ervan $\epsilon$ afleidt en de andere niet. In tweede instantie schrappen we koppels $(p,q)$ waarvoor een symbool $a$ bestaat zodat $((\delta(p,a)),(\delta(q,a)))$ niet behoort tot de huidige set want ook die zijn in tegenspraak met de regel. We gaan hiermee door totdat we geen koppels meer kunnen schrappen en dus de verzameling van toestanden $f$-verschillend is. 
\end{alg}

\begin{lem}[DFA$_{\text{min}}$]{minDFA2}
    Als een DFA $N$ = $(Q_1,\Sigma, \delta_1, q_s, F_1)$  een DFA is zonder onbereikbare toestanden en waarin elke twee toestanden $f$-verschillend zijn, dan bestaat er geen machine met strikt minder toestanden die dezelfde taal bepaalt. De DFA $N$ is dan een minimale DFA of DFA$_{\text{min}}$ voor deze taal.

    % \vspace{-0.3cm}
\end{lem}

\begin{prf}[DFA$_{\text{min}}$]{prf - minDFA}
    Veronderstel dat \(Q_1 = \{q_s,q_1, \ldots, q_n\}\) waarbij \(q_s\) de starttoestand is, stel dat \(N_2 = (Q_2,\Sigma, \delta_2, q_s, F_2)\) een DFA is met minder toestanden dan $N$.
    Vermits in $N$ elke toestand bereikbaar is, bestaan er strings \(\forall i \in \mathbb{N}_0^+: s_i\) zodanig dat \(\delta_1^*(q_s,s_i) = q_i\). 
    Vermits \(N_2\) minder toestanden heeft moet voor een \(i \neq j: \delta_2^*(p_s,s_i) = \delta_2^*(p_s,s_j)\). Vermits \(q_i\) en \(q_j\)
    $f$-verschillend zijn, is er een string \(s\) zodat \(\delta_1^*(q_i,s) \in F_1\) en \(\delta_1^*(q_j,s) \notin F_1\) of omgekeerd.
    Dus ook \(\delta_1^*(q_s,s_is) \in F_1\) en \(\delta_1^*(q_s,s_js) \notin F_1\) of omgekeerd. Dit betekent dat DFA$_1$ van de strings $s_is$ en $s_js$ er juist één accepteert.
    Maar N$_2$ zal beide strings $s_is$ en $s_js$ accepteren of geen van beiden, aangezien het parsen van $s_i$ en $s_j$ naar dezelfde node leidt, waarna hetzelfde pad gevolgd wordt om $v$ te parsen.
    Dus kunnen de DFA's N en N$_2$ niet dezelfde taal bepalen.
    \vspace{-0.3cm}
\end{prf}

\begin{theo}[DFA isomorfisme]{DFA isomorfisme}
    Een DFA $N_1 = (Q_1, \Sigma, \delta_1, q_{s_1}, F_1)$ is \textbf{isomorf} met een DFA $N_2 = (Q_2, \Sigma, \delta_2, q_{s_2}, F_2)$ als er een bijectie $b: Q_1 \to Q_2$ bestaat zodanig dat
    \begin{itemize}
        \item $b(F_1) = F_2$
        \item $b(q_{s_1}) = q_{s_2}$
        \item $b(\delta_1(q,a)) = \delta_2(b(q),a)$
    \end{itemize}
    Twee isomorfe DFA's bepalen dus dezelfde taal. \\

    \textbf{Opmerking:} een minimale DFA is dus altijd uniek op isomorfisme na, sinds elke twee minimale DFA's van een DFA (op een isomorfisme na) dezelfde componenten hebben.
\end{theo}

\newpage

\subsection{Myhill-Nerode relaties op $\Sigma^*$}

\vspace{0.5cm}

\begin{theo}[Fijnheid van partities]{Fijnheid van partities}
    Een partitie $P_1$ is \textbf{fijner} dan een partitie $P_2$ indien
    \begin{equation*}
        \forall x \in P_1,\ \exists y \in P_2: \ x \subseteq y
    \end{equation*}
    Het omgekeerde van fijn is \textbf{grof}.
\end{theo}

\begin{theo}[$\sim_{\text{DFA}}$]{DFAeqklassen}
    Voor een DFA $N = (Q, \Sigma, \delta, q_s, F)$ definiëren we de relatie $\sim_{\text{DFA}}$ op $\Sigma^*$ als volgt:
    \begin{equation*}
        x \sim_{\text{DFA}} y \ \Leftrightarrow \ \delta^*(q_s,x) = \delta^*(q_s,y)
    \end{equation*}
    In woorden: er geldt $x \sim_{\text{DFA}} y$ als en slechts als het parsen van $x$ en $y$ vanuit $q_s$ leidt tot dezelfde toestand $q$, dus $x,y \in \text{reach}(q)$.
\end{theo}

\begin{pro}[$\sim_{\text{DFA}}$]{pro - DFAeqklassen}
    \begin{itemize}
        \item Rechts congruentie van $\sim$: $\forall x,y \in \Sigma^*, \ a \in \Sigma: \ x \sim y \ \Rightarrow \ xa \sim ya $
        \item het aantal equivalentieklassen van $\sim$ is eindig, m$.$a$.$w$.$ $\sim$ heeft een eindige index
        \item $\sim$ verfijnt $\sim_L$, of: $x \sim y \ \Rightarrow \ x \sim_L y$
    \end{itemize}
\end{pro}

\begin{theo}[Myhill-Nerode relatie]{Myhill-Nerode relatie}
    Een equivalentierelatie $\sim$ tussen strings is een \textbf{Myhill-Nerode relatie} MN(L) voor een taal $L$ als de equivalentieklasse
    voldoet aan \textbf{bovenstaande} eigenschappen.
\end{theo}

\begin{lem}[DFA$_{\sim}^{\text{L}}$]{DFAsimL}
    \vspace{-0.1cm}
    Gegeven een taal $L$ over $\Sigma$ en een MN(L)-relatie $\sim$ op $\Sigma^*$, dan is DFA$_{\sim}^{\text{L}} = (Q, \Sigma, \delta, q_s, F)$ een DFA die L bepaalt, waarbij
    \begin{itemize}
        \item $Q = \{x_{\sim} \ | \ x \in \Sigma^* \}$: elke equivalentieklasse is een toestand
        \item $\delta(x_{\sim},a) = (xa)_{\sim}$
        \item $q_s = \epsilon_{\sim}$: de starttoestand bereik je met $\epsilon$
        \item $F = \{x_{\sim} \ | \ x \in L \}$: de eindtoestanden worden bereikt door een string in L
    \end{itemize}  
    \vspace{-0.2cm}
\end{lem}

\begin{prf}[DFA$_{\sim}^{\text{L}}$]{prf - DFAsimL}
    \vspace{-0.1cm}
    Dat $\delta$ goed gedefinieerd is, kan je bewijzen door gebruik te maken van de rechtse congruentie van $\sim$.
    Verder zijn alle ingrediënten van de DFA duidelijk, in het bijzonder ook dat $Q$ slechts een eindig aantal toestanden bevat.
    We moeten nog bewijzen dat $L_{\text{DFA}_{\sim}^{\text{L}}} = L$:
    \begin{equation*}
        x \in L_{\text{DFA}_{\sim}^{\text{L}}} \ \Leftrightarrow \ \delta^*(q_s,x) \in F \ \Leftrightarrow \ x_{\sim} \in F \ \Leftrightarrow \ x \in L
    \end{equation*}
    De middelste overgang bekom je door met inductie op de lengte van de string $x$ te bewijzen dat $\delta^*(\epsilon_{\sim},x) = (x)_{\sim}$.
\end{prf}

\begin{lem}[$\sim_{\text{DFA}}$ en $\sim$ zijn elkaars inverse]{simDFA en sim zijn elkaars inverse}
    Voor elke taal $L$ geldt dat de functie die DFA's van $L$ afbeeldt op de de overeenkomstige MN(L)-relatie $\sim_{\text{DFA}}$ en de functie 
    die MN(L)-relaties $\sim$ afbeeldt op de overeenkomstige DFA$_{\sim}^{\text{L}}$, elkaars inversen zijn op een DFA-isomorfisme na.
\end{lem}

% \begin{prf}[$\sim_{\text{DFA}}$ en $\sim$ zijn elkaars inverse]{simDFA en sim zijn elkaars inverse}
% \end{prf}

\begin{lem}[Infimumrelatie van Myhill-Nerode relaties]{Infimumrelatie van Myhill-Nerode relaties}
    \vspace{-0.1cm}
    Als $E$ een niet lege verzameling van MN(L) relaties is, dan is ook het infimum $\sim_{\text{inf}}$ van $E$ een MN(L) relatie.
    $\sim_{\text{inf}}$ is de transitieve sluiting van de unie van $E$. Dit betekent dat
    \begin{equation*}
        x \sim_{\text{inf}} y \ \Leftrightarrow \ i \in [0, n-1], \ \sim_i \ \in E: \ x = x_0 \sim_0 x_1 \sim_1 \ldots \sim_{n-1} x_n = y
    \end{equation*}
    \vspace{-0.7cm}
\end{lem}

% \newpage

\begin{prf}[Infimumrelatie van Myhill-Nerode relaties]{prf - Infimumrelatie van Myhill-Nerode relaties}
    % We zagen al dat het infimum van een niet lege verzameling $E$ van equivalentierelaties zelf ook een equivalentierelatie is.

    % \vspace{-0.1cm}

    \begin{itemize}
        \item 
            \textbf{Eindigheid:} $\sim_{\text{inf}}$ is een superset van elke willekeurige $\sim \ \in E$ en heeft dus minder equivalentieklassen
            dan $\sim$. Elke $\sim$ heeft slechts een eindig aantal equivalentieklasse, zodoende ook $\sim_{\text{inf}}$.
        \item 
            \textbf{Rechts congruentie:} Stel $x \sim_{\text{inf}} y$ dan bestaat de sequentie 
            \begin{equation*}
                x = x_0 \sim_0 x_1 \sim_1 \ldots \sim_{n-1} x_n = y
            \end{equation*}
            Aangezien elke $\sim_i$ rechts congruent is, geldt voor elke $a \in \Sigma$ dat 
            \begin{equation*}
                xa = x_0a \sim_0 x_1a \sim_1 \ldots \sim_{n-1} x_na = ya
            \end{equation*}
            Bijgevolg geldt dat $xa \sim_{\text{inf}} ya$ en dus dat $\sim_{\text{inf}}$ rechts congruent is.
        \item 
            \textbf{Verfijnen van $\sim_L$:} Stel $x \sim_{\text{inf}} y$ zodat er een sequentie bestaat 
            \begin{equation*}
                x = x_0 \sim_0 x_1 \sim_1 \ldots \sim_{n-1} x_n = y
            \end{equation*}
            Aangezien elke $\sim_i$ een verfijning is van $\sim_L$, geldt
            \begin{equation*}
                x_0 \in L \Leftrightarrow x_1 \in L \Leftrightarrow \ldots \Leftrightarrow x_n \in L
            \end{equation*}
            We bekomen $x \in L \Leftrightarrow y \in L$ en dus dat $\sim_{\text{inf}}$ een verfijning is van $\sim_L$.
    \end{itemize}

    \vspace{-0.3cm}
\end{prf}

\newpage

\begin{lem}[MN(L) toebehorend aan een mininale DFA]{ MN(L) toebehorend aan een mininale DFA}
    \vspace{-0.1cm}
    De DFA van $\sim_{\text{inf}}$, DFA$_{\sim_{\text{inf}}}$, is een minimale DFA$_{\text{min}}$ van $L$. Elke minimale DFA is van $L$ is isomorf met mekander, en dus ook met DFA$_{\sim_{\text{inf}}}$.
    \vspace{-0.1cm}
\end{lem}

\begin{prf}[MN(L) toebehorend aan een mininale DFA]{prf - MN(L) toebehorend aan een mininale DFA}
    \vspace{-0.1cm}
    Voor elke MN(L) relatie $\sim$ geldt ofwel dat $\sim \ = \ \sim_{\text{inf}}$, ofwel bestaan $x,y$ zodat $x \nsim y$ maar $x \sim_{\text{inf}} y$, en dan heeft $\sim$ strikt meer equivalentieklassen dan $\sim_{\text{inf}}$. Uit de overeenkomst tussen DFA's en MN(l) relaties volgt dat elke DFA die $L$ bepaalt, ofwel isomorf is aan DFA$_{\text{sup}}$, de DFA van $\sim_{\text{inf}}$, ofwel heeft hij strikt meer toestanden dan DFA$_{\text{sup}}$. Dus, DFA$_{\sim_{\text{inf}}}$ is een minimale DFA van $L$ waarmee elke minimale DFA van $L$ isomorf is.
\end{prf}

\begin{pro}[MN(L) toebehorend aan een mininale DFA]{pro - MN(L) toebehorend aan een mininale DFA}
    \vspace{-0.1cm}
    Het kan nu ook bewezen worden dat de MN(L) relatie die hoort bij de minimale DFA voldoet aan:
    \begin{equation*}
        x \sim_{\text{inf}} y \ \Leftrightarrow \  \forall s \in \Sigma^*: \ ( xs \in L \Leftrightarrow ys \in L )
    \end{equation*}
    Het is een vorm van $f$-gelijkheid gedefinieerd op strings in plaats van op toestanden.
\end{pro}

\begin{lem}[Stelling van Myhill-Nerode]{Stelling van Myhill-Nerode}
    \vspace{-0.1cm}
    Laat $L \subseteq \Sigma^*$ een taal zijn over $\Sigma$. De volgende drie uitspraken zijn dan equivalent:
    \begin{itemize}
        \item[$\Leftrightarrow$] $L$ is regulier
        \item[$\Leftrightarrow$] er bestaat een Myhill-Nerode relatie voor $L$
        \item[$\Leftrightarrow$] 
            definieer $\sim$ op $\Sigma^*$ als volgt:
            \vspace{-0.15cm}
            \begin{equation*}
                x \sim y \ \Leftrightarrow \ \forall s \in \Sigma^*: \ ( xs \in L \Leftrightarrow ys \in L );
            \end{equation*}
            \vspace{-0.15cm}
            de relatie $\sim$ heeft een eindige index
    \end{itemize}
    \vspace{-0.2cm}
\end{lem}   

\subsection{Pompend lemma voor reguliere talen}

\vspace{0.5cm}

\begin{lem}[Pompend lemma voor reguliere talen]{Pompend lemma voor reguliere talen}
    \vspace{-0.1cm}
    Voor een reguliere taal $L$ bestaan een pomplengte $d$, zodanig dat als $s \in L$ en $|s| \geq d$, 
    dan bestaat er een verdeling van $s$ in stukken $x$, $y$ en $z$ zodanig dat $s = xyz$ en \\
    \begin{minipage}{0.56\textwidth}
        \begin{itemize}
            \item $\forall i \in \mathbb{N}_0^+: \ xy^iz \in L$
            \item $|y| > 0$
            \item $|xy| \leq d$
        \end{itemize}
    \end{minipage}
    \hspace{0.2cm}
    \begin{minipage}{0.4\textwidth}
       \hspace{1.25cm}\includegraphics[scale = 0.25]{Images/VerdelingStrings.png}
    \end{minipage}
    \vspace{-0.3cm}
\end{lem}

\newpage

\begin{prf}[Pompend lemma voor reguliere talen]{prf - Pompend lemma voor reguliere talen}
    Neem een DFA die $L$ bepaalt, neem $d = \#Q$ en neem een willekeurige $s = a_1 \ldots a_n \in L$ met $n \geq d$.
    Beschouw de accepterende sequentie
    \begin{equation*}
        q_s = q_0 \overset{a_1}{\longrightarrow} q_1 \overset{a_2}{\longrightarrow} \ldots \overset{a_n}{\longrightarrow} q_n \in F
    \end{equation*}
    Deze rij van toestanden heeft lengte $n+1$, wat strikt groter is dan $d$. Neem de eerste $d+1$ toestanden van de deze rij,
    dus $q_0,\ldots, q_d$. Er zijn maar $d$ verschillende toestanden, dus er zijn twee gelijke toestanden. 
    Stel dat $q_i = q_j$ met $ 0 \leq i < j \leq d$, dan nemen we $x = a_1 \ldots a_i$, $y = a_{i+1} \ldots a_j$ en $z$ de rest van de string. 
    Alles volgt nu direct, zie desnoods te illustratie in de stelling.
\end{prf}

% \subsection{Varianten van eindige toestandsautomaten}

% \vspace{0.5cm}

% \begin{theo}[Transducer]{Transducer}
%     \begin{minipage}{.66\textwidth}
%         Een transducer zet een string om in een andere: we passen de definitie van een DFA een beetje aan, zodat ook output kan geproduceerd worden
%         De labels zijn nu van de vorm $a/x$ waarbij $a$ in het inputalfabet zit en $x$ in een outputalfabet (inbegrepen de lege string). 
%         Wat voor de $/$ staat wordt gebruikt om de weg te vinden in de transducer alsof het een DFA was. Wat na de $/$ staat wordt op de output gezet als die boog genomen wordt. 
%         De transducer hiernaast accepteert elke string en geeft als output een 1 voor elke b die vlak na een a komt.
%     \end{minipage}
%     \begin{minipage}{.3\textwidth}
%         \vspace{-0.3cm}\hspace{0.3cm}\includegraphics[scale = 0.3]{Images/Transducer.png}
%     \end{minipage}
% \end{theo}

% \begin{theo}[Optelchecker]{Optelchecker}
%     \begin{minipage}{.75\textwidth}
%         Een DFA kan alleen gebruikt worden om te beslissen of een string behoort tot een taal.
%         Zo zou je kunnen een taal definiëren van strings die correcte optellingen voorstellen en als die taal regulier is er een DFA voor bouwen.
%         Hier is een poging: $\Sigma = \{0,1\}$. De twee getallen  die we willen optellen en het resultaat komen in binair, omgekeerd en we maken ze even lang door bij de kortste(n) wat leidende nullen toe te voegen.
%         Dus als we $3$ willen optellen bij $13$, met resultaat $16$, dan hebben we de drie bitstrings $11000$, $10110$ en $00001$. Die mengen we nu systematisch,
%         t$.$t$.$z$.$ we maken groepjes van $3$ bits die op de i-de plaats voorkomen en schrijven die groepjes achter elkaar. Dus we hebben 
%         \begin{equation*}
%             110  \ 100 \ 010 \ 010 \ 001
%         \end{equation*}
%         waarbij de blanco’s enkel dienen om de groepering per drie te laten zien. Dus de string 
%         \begin{equation*}
%             110100010010001
%         \end{equation*}
%         stelt de correcte optelling 3+13=16 voor.
%         Een DFA voor de taal van correcte optellingen staat in de figuur hiernaast.
%     \end{minipage}
%     \begin{minipage}{.21\textwidth}
%         \vspace{-0.3cm}\includegraphics[scale = 0.35]{Images/Optelchecker.png}
%     \end{minipage}
% \end{theo}

% \newpage

% \begin{theo}[Optel-transducer]{Optel-transducer}
%     Optellen bestaat eigenlijk in: gegeven twee getallen als input, output de som. Dat kan met een transducer: gebruik dezelfde voorstelling van de twee getallen die je wil optellen als hiervoor, 
%     en meng die op dezelfde manier, dus 3+13 wordt voorgesteld als de string
%     \begin{equation*}
%         1110010100.
%     \end{equation*}
%     \begin{center}
%         \hspace{0.25cm}\includegraphics[scale = 0.45]{Images/OptelTranducers.png}
%     \end{center}
% \end{theo}

% \begin{theo}[Two-way finite automata]{Two-way finite automata}
%     Een DFA staat ook wel gekend als een one-way finite automata, omdat de input van links naar rechts gelezen wordt en de automaat niet terug kan gaan.
%     Een two-way finite automata 2DFA is een DFA die ook van rechts naar links kan lezen. De automaat kan dus terugkeren naar vorige toestanden.
%     \vspace{-0.05cm}
% \end{theo}

% \begin{theo}[Büchi automaten]{Büchi automaten}
%     Büchi automaten trekken op NFA's maar je geeft er geen eindige strings aan, wel oneindige lange: er is dus geen moment waarop je string eindigt bij het doorlopen.
%     De oneindige string $s$ wordt aanvaard indien de rij toestanden waarlangs je passeert oneindig dikwijls een aanvaardende toestand heeft.
%     \vspace{-0.05cm}
% \end{theo}

\subsection{Contextvrije talen en hun grammatica}

\vspace{0.5cm}

\begin{theo}[Contextvrije grammatica - CFG]{Contextvrije grammatica - CFG}
    Een contextvrije grammatica is een 4-tal $(V, \Sigma, R, S)$ waarbij
    \begin{itemize}
        \item $V$ een eindige verzameling is van niet-eindsymbolen of \textbf{variabelen}
        \item $\Sigma$ een eindige alfabet is van eindsymbolen of \textbf{terminals}, disjunct met $V$
        \item $R$ is een eindige verzameling van regels of \textbf{producties}: een regel is een koppel van één niet-eindsymbool en een strings van elementen uit $V \cup \Sigma_{\epsilon}$. 
              We schrijven $u \to v$ voor een regel $(u,v)$.
        \item $S \in V$ is het \textbf{startsymbool}
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\begin{theo}[Taal bepaald door een CFG]{Taal bepaald door een CFG}
    De taal $L_{\text{CFG}}$ bepaald door een CFG $(V, \Sigma, R, S)$ is de verzameling strings $s$ over $\Sigma$ zodanig dat $S \Rightarrow^* s$. In formulevorm:
    \begin{equation*}
        L = \{ w \in \Sigma^* \ | \ S \Rightarrow^* w \}
    \end{equation*}
    \vspace{-0.5cm}
\end{theo}

\begin{theo}[Afleiding m$.$b$.$v$.$ een CFG]{Afleiding m.b.v. een CFG}
    Gegeven een CFG $(V, \Sigma, R, S)$. Een string $f$ over $V \cup \Sigma_{\epsilon}$ wordt afgeleid uit een string $b$ over $V \cup \Sigma_{\epsilon}$ 
    m$.$b$.$v$.$ de CFG als er een eindige rij strings $s_0, \ldots, s_n$ bestaat zodanig dat
    \begin{itemize}
        \item $s_0 = b$
        \item $s_n = f$
        \item $\forall i \in [0,n-1]: \ s_i \to s_{i+1}$
    \end{itemize} 
    We noteren: $s_i \Rightarrow s_{i+1}$ en $b \Rightarrow^* f$. 
    \vspace{-0.1cm}
\end{theo}

\begin{pro}[Implementaties van afleidingen m$.$b$.$v$.$ een CFG]{pro - Afleiding m.b.v. een CFG}
    \begin{itemize}
        \item \textbf{diepte-eerst}: bij elke overgang $i$ is het vervangen symbool $X$ de grootste index heeft van alle niet-terminaal symbool in $s_i$. Dit is een \textbf{niet-deterministische} strategie.
        \item \textbf{links-eerst}: bij elke overgang $i$ is het vervangen symbool $X$ het meest linkse niet-terminaal symbool in $s_i$. Een links-eerst strategie is ook een diepte-eerst strategie, maar niet noodzakelijk omgekeerd.
        \item \textbf{breedte-eerst}: bij elke overgang $i$ is het vervangen symbool $X$ de kleinste index heeft van alle niet-terminaal symbool in $s_i$. Dit is een \textbf{niet-deterministische} strategie.
        \begin{itemize}
            \item breedte-eerst, linkst eerst: bij elke overgang $i$ is het vervangen symbool $X$ het meest linkse symbool met kleinste index heeft van alle niet-terminaal symbool in $s_i$.
        \end{itemize}
    \end{itemize}
    \vspace{-0.2cm}
\end{pro}

\begin{pro}[Ambiguïteit van een CFG]{pro - Ambiguïteit van een CFG}
    \vspace{-0.1cm}
    Een CFG is ambigu indien er strings bestaan die meerdere meest-linkse parsings bezitten.
    \vspace{-0.1cm}
\end{pro}

\begin{theo}[Equivalente CFG's]{Equivalente CFG's}
    \vspace{-0.1cm}
    Twee contextvrije grammatica's CFG$_1$ en CFG$_2$ zijn \textbf{equivalent} als ze dezelfde taal bepalen, en dus $L_{\text{CFG}_1} = L_{\text{CFG}_2}$.
    \vspace{-0.1cm}
\end{theo}

\begin{theo}[Contextvrije taal - CFL]{Contextvrije taal - CFL}
    \vspace{-0.1cm}
    Een taal $L$ is \textbf{contextvrij} indien er een CFG bestaat die $L$ bepaalt, en dus $L = L_{\text{CFG}}$. \\

    \vspace{-0.1cm}
    \textbf{Opmerking:} niet elke CFL heeft een niet-ambigue CFG
\end{theo}

\begin{theo}[Chomsky normaalvorm]{Chomsky normaalvorm}
    \vspace{-0.1cm}
    Een CFG $(V, \Sigma, R, S)$ heeft de \textbf{Chomsky normaalvorm} als elke regel één van de volgende vormen heeft:
    \begin{itemize}
        \item $A,B,C \in V: \ A \to BC$
        \item $A \in V, \ \alpha \in \Sigma: \ A \to \alpha$ 
        \item $S \to \epsilon$
    \end{itemize}
    \vspace{-0.3cm}
\end{theo}

\begin{lem}[Equivalente Chomsky normaalvorm]{Equivalente Chomsky normaalvorm}
    \vspace{-0.1cm}
    Voor elke CFG $(V, \Sigma, R, S)$ bestaat er een equivalentie CFG in Chomsky normaalvorm.
    \vspace{-0.1cm}
\end{lem}

\newpage

\begin{prf}[Equivalente Chomsky normaalvorm]{prf - Equivalente Chomsky normaalvorm}
    We vertrekken van een willekeurige CFG en transformeren hem terwijl we equivalentie bewaren naar Chomsky Normaalvorm.
    \begin{enumerate}
        \item 
            Vervang alle voorkomens van $S$ door een nieuw symbool $X$, en daarna voeg de regel $S \to X$ toe. Zo komt $S$ enkel links voor.
            Zo wordt 1 van de voorwaarden voldaan. Deze stap is evident equivalentiebewarend.
        \item 
            Neem de verzameling van alle regels. Itereer de volgende operatie zo lang tot een fixpunt bereikt wordt:
            \begin{itemize}
                \item Selecteer een regel $A \to \epsilon$ en een regel $B \to \alpha A \beta$.
                \item Voeg de regel $B \to \alpha\beta$ toe.
            \end{itemize}
            Deze stap is equivalentiebewarend. Daarvoor moet aangetoond worden dat elke iteratie equivalentiebewarend is. Kortom,
            als $B \to \alpha A \beta$ toegevoegd wordt, dan kan een string geschreven worden met die regel als en slechts als de strings geschreven
            kan worden zonder deze regel. Het is evident omdat het herschrijven met $B \to \alpha\beta$ kan gesimuleerd worden met $B \to \alpha a \beta$ en $A \to \epsilon$.
            Tenslotte: verwijder alle regels $A \to \epsilon$ voor $A \neq S$. Ook deze stap is equivalentiebewarend. Neem een parsing boom
            $S \to \ldots$; de wortel is $S$, elke node is gelabeld met een symbool $A$, elke node die geen blad is eheft een geordende rij kinderen
            gelabeld $BC \ldots D$ zodat $A \to BC \ldots D$ een regel is, en de bladeren van de bomen vormen een sequentie van terminale symbolen. 
            Dan is het vrij duidelijk dat elke string van de CFL zo'n parsing boom heeft. Ook dat deze boom kan hervormd worden tot een boom
            die gebruik maakt van de toegevoegde regels en geen gebruik maakt van regels $A \to \epsilon$.
        \item
            Nu willen we afgeraken van de regels van de vorm $A \to B$. Voor een regel van de vorm $\mathcal{E} = A \to B$ en een regel van de vorm
            $\mathcal{R} = B \to \gamma$, definieer de regel $\mathcal{U}(\mathcal{E},\mathcal{R}) = A \to \gamma$. Zolang er regels van de vorm $\mathcal{E} = A \to B$ zijn (waaron $B$ ook een niet-terminal is)
            en regels van de vorm $\mathcal{R} = B \to \gamma$ zijn, voeg de regel $\mathcal{U}(\mathcal{E},\mathcal{R})$ toe. Nadat dit eindigt, verwijderen we uit de bekomen grammatica alle regels van de vorm $A \to B$.
            Deze stap is equivalentiebewarend. Neem een string $s$ die kan afgeleid worden met de regels van de vorm $A \to B$. Dan kan $s$ ook afgeleid worden zonder deze regels.
        \item 
            We hebben nu nog drie soorten regels te behandelen:
            \begin{enumerate}
                \item $A \to \gamma$ waar $\gamma$ uit juist twee niet-eindsymbolen bestaat.
                \item $A \to \gamma$ waar $\gamma$ uit minstens twee symbolen bevat: vervang elke terminal $a$ door een niet-terminaal $A_a$ en voeg de regel $A_a \to a$ toe.
                \item eventueel $S \to \epsilon$: die mag blijven.
            \end{enumerate}
        \item 
            De regels van de vorm 
            \begin{equation*}
                n > 2: A \to X_1X_2 \ldots X_n
            \end{equation*} 
            vervang je door
            \begin{equation*}
                A \to X_1Y_1, \ Y_1 \to X_2Y_2, \ldots, \ Y_{n-2} \to X_{n-1}X_n
            \end{equation*}
    \end{enumerate}
    Hierbij is het duidelijk dat bij de transformatie naar de Chomsky Normaalvorm de grammatica equivalent blijft.
\end{prf}

\subsection{Push-down automaat}

\vspace{0.5cm}

\begin{theo}[Push-down automaat]{Push-down automaat}
    Een push-down automaat PDA $(Q,\Sigma,\Gamma,\delta,q_s,F)$ is een automaat waarbij

    \vspace{0.2cm}
    \begin{minipage}{.6\textwidth}
        \begin{itemize}
            \item $Q$ is een eindige verzameling toestanden
            \item $\Sigma$ is een eindig inputalfabet
            \item $\Gamma$ is een eindig stapelalfabet
            \item $\delta: Q \times \Sigma_{\epsilon} \times \Gamma_{\epsilon} \to \mathcal{P}(Q \times \Gamma_{\epsilon})$
            \item $q_s$ is de starttoestand
            \item $F \subseteq Q$ is een verzameling eindtoestanden
        \end{itemize}
    \end{minipage}
    \begin{minipage}{.36\textwidth}
        \includegraphics[scale = 0.22]{Images/PDA.png}
    \end{minipage}
    \vspace{0.5cm} \\
    \textbf{Opmerking:} de bedoeling van een label zoals $\alpha, \beta \to \gamma$ op een boog is 
    \begin{itemize}
        \item indien $\alpha$ het eerste symbool is van de huidige string
        \item en $\beta$ staat op de top van de stapel
        \item 
            volg dan de boog en 
            \begin{itemize}
                \item verwijder $\alpha$ van de string
                \item verwijder $\beta$ van de string
                \item zet $\gamma$ op de stapel
            \end{itemize}
    \end{itemize}
    waarbij $\alpha, \beta, \gamma \in \Sigma_{\epsilon}$.
\end{theo}

\begin{theo}[Aanvaarding van een string $s$ door een PDA]{Aanvaarding van een string s door een PDA}
    Een string $s$ wordt aanvaard door een PDA indien $s$ kan worden opgesplitst in delen $i \in [1,m]: \ w_i \in \Sigma_\epsilon$, er toestanden $j \in [0,n]: \ q_j$ zijn en 
    stacks $k \in [0,m]: \ \text{stack}_k \in \Gamma^*$, zodanig dat 
    \begin{itemize}
        \item $\text{stack}_0 = \epsilon$: de stack is leeg in het begin
        \item $q_0 = q_s$: we vertrekken in de begintoestand
        \item $q_m \in F$: we komen aan in een eindtoestand met een lege string
        \item $x,y \in \Gamma_\epsilon: \ (q_{i+1},y) \in \delta(q_i,w_{i+1},x)$ en $x,y \in \Gamma_\epsilon, \ t \in \Gamma^*: \ \text{stack}_i = xt, \ \text{stack}_{i+1} = yt$
        % \item $x,y \in \Gamma_\epsilon, \ t \in \Gamma^*: \ \text{stack}_i =
        % xt, \ \text{stack}_{i+1} = yt$.
    \end{itemize}  
    \vspace{-0.3cm}
\end{theo}

\begin{theo}[Taal bepaald door een PDA]{Taal bepaald door een PDA}
    \vspace{-0.1cm}
    De taal $L$ bepaald door een PDA bestaat uit alle strings die door de PDA
    aanvaard worden.
    \vspace{-0.1cm}
\end{theo}

\newpage

\subsection{Equivalentie van CFG en PDA}

\vspace{0.5cm}

\begin{lem}[Equivalentie van CFG en PDA]{Equivalentie van CFG en PDA}
    Elke push-down automaat bepaalt een contextvrije taal en elke contextvrije taal wordt bepaald door een push-down automaat. We onderscheiden de twee gevallen:
    \begin{itemize}
        \item CFG $\to$ PDA: 
        We kunnen een PDA bouwen voor een CFG met drie toestanden $q_s,x,q_f$ waarbij $q_s$ de starttoestand is, $q_f$ de unieke eindtoestand is en $x$ een toestand is die enkel dient om de stack te legen. De transitie bestaat uit 4 soorten overgangen:
        \begin{itemize}
            \item $\delta(q_s, \epsilon, \epsilon) = (x, S\$)$, met $S$ het startsymbool van de CFG,
            \item $\delta(x, \epsilon, X) = (x, \gamma)$, voor elke regel $X \to \gamma$ van de CFG, 
            \item $\delta(x,A,A) = (x, \epsilon)$ voor elk terminaal symbool A,
            \item $\delta(x, \epsilon, \$) = (q_f, \epsilon)$.
        \end{itemize}
        \item PDA $\to$ CFG: 
        We kunnen een CFG $(V, \Sigma, R, S)$ maken uit een PDA $(Q,\Sigma,\Gamma,\delta,q_s,F)$ waarbij
        \begin{itemize}
            \item $\forall p,q \in Q: \ V = A_{p,q}$
            \item $S = A_{q_s,q_f}$
            \item 
                R bestaat uit 3 delen:
                \begin{enumerate}
                    \item $\forall p \in Q: A_{p,p} \to \epsilon$
                    \item $\forall p,q,r \in Q: \ A_{p,q} \to A_{p,r}A_{r,q}$
                    \item $\forall p,q,r,s \in Q, a,b \in \Sigma_{\epsilon}, t \in \Gamma, (r,t) \in \delta(p,a,\epsilon),(q,\epsilon) \in \delta(s,b,t): \ A_{p,q} \to aA_{r,s}b$
                \end{enumerate}
        \end{itemize}
    \end{itemize}
    \vspace{-0.2cm}
\end{lem}

\begin{pro}[Equivalentie van CFG en PDA]{pro - Equivalentie van CFG en PDA}
    \begin{itemize}
        \item als een taal door een PDA wordt bepaald, dan is die contextvrij.
        \item elke reguliere taal is contextvrij, want elke NFA is een PDA waarbij de stapel niet gebruikt wordt.
    \end{itemize}
\end{pro}

% \begin{prf}[Equivalentie bij CFG $\to$ PDA]{prf - Equivalentie van CFG en PDA}
%     \vspace{-0.1cm}
%     Het bewijs gaat door aan te tonen dat er 1-1 verband is tussen accepterende uitvoeringen van de PDA van een string $s$ en meest linkse afleidingen (aka depth-first-left-to-right adleidingen) in de CFG van $s$.
% \end{prf}

\subsection{Pompend lemma voor contextvrije talen}

\vspace{0.5cm}

\begin{lem}[Pompend lemma voor contextvrije talen]{Pompend lemma voor contextvrije talen}
    \vspace{-0.1cm}
    Voor een contextvrije taal $L$ bestaan een getal $p$ (de pomplengte) zodanig dat elke string $s$ van $L$ met lengte
    strikt groter dan $p$ kan opgedeeld worden in $5$ stukken $u,v,x,y,z \in \Sigma^*$ zodanig dat $s = uvxyz$
    \begin{itemize}
        \item $\forall i \in \mathbb{N}_0^+: \ uv^ixy^iz \in L$
        \item $|vy| > 0$
        \item $|vxy| \leq p$
    \end{itemize}
    \vspace{-0.2cm}
\end{lem}

\begin{prf}[Pompend lemma voor contextvrije talen]{prf - Pompend lemma voor contextvrije talen}
    Als $L$ eindig is dan is de stelling triviaal voldaan. Immers, dan heeft $L$ een langste string $s$; 
    neem $p = |s|$. Dan zijn er geen strings met lengte strikt groter dan $p$, en
    dan is de stelling triviaal voldaan. Veronderstel dus dat $L$ oneindig is en bijgevolg strings van willekeurige lengte bevat en dat de CFG voor $L$ in Chomsky normaalvorm is, dit is makkelijker en immers elke CFG heeft een equivalente CFG in Chomsky normaalvorm. Dus, elke regel heeft nu ofwel twee ofwel nul niet-terminalen aan de rechterkant, en het startsymbool $S$ komt niet rechts voor. Laat het aantal niet-eindsymbolen in de CFG gelijk aan $n$ zijn. We willen nu aantonen dat 
    \begin{itemize}
        \item er een pomplengte $p$ bestaat zodat de parse tree van elke string van lengte strikt groter dan $p$, een tak bevat met een herhaald niet-terminaal symbool $X$;
        \item als de parse tree van $s$ een tak bevat met een herhaald niet-terminaal symbool $X$, dan is $s$ van de vorm $uvxyz$ zodat $s$ kan gepompt worden.
    \end{itemize} 
    Voor de eerste stap gebruiken we het duivenhokprincipe, maar nu op de parse tree voor voldoende lange strings.  De grootste parse tree van de CFG zonder takken met herhaalde niet-terminalen, bevat enkel paden met maximaal $n$ niet-terminalen. Aangezien elke niet-terminale node hoogstens $2$ kinderen heeft, bevat een dergelijke boom hoogstens $2^{n-1}$ bladeren. De string bevat evenveel symbolen als er bladeren zijn, dus hoogstens $2^{n-1}$. Neem de pomp lengte $p = 2^{n-1}$. Zij $s$ een string in $L$ van meer dan

    \begin{minipage}{.7\textwidth}
        $p$ symbolen. De parse tree bevat dus een tak met meer dan $n$ niet-eindsymbolen. We selecteren een langste pad in deze parse tree (mogelijks bestaat er meer dan 1 langste pad). Dit pad bevat meer dan $n$ niet-terminalen en dus wordt een niet-terminaal herhaald. Zij $X$ het herhaalde symbool op dat pad met het laagste voorlaatste voorkomen. Het laagste voorkomen van $X$ duiden we aan door $X_1$ en het voorlaatste voorkomen door $X_2$.  We kunnen nu uit die parse tree (zie figuur) een afleiding construeren waarvan we enkel wat tussenstappen laten zien
    \end{minipage}
    \begin{minipage}{.26\textwidth}
        \begin{center}
            \includegraphics[scale = 0.35]{Images/ParseTree225.png}
        \end{center}
    \end{minipage}
    \begin{equation*}
        u,v,x,y,z \in \Sigma^*: \ S \Rightarrow^* uX_{2}z \Rightarrow^* uvX_{1}yz \Rightarrow^* uvxyz
    \end{equation*}
    waarbij $v$ en $y$ niet tegelijkertijd leeg zijn. Vermits dit een geldige afleiding is, is 
    \begin{equation*}
        S \Rightarrow^* uX_{2}z \Rightarrow^* uxz
    \end{equation*}
    dat ook en ook 
    \begin{equation*}
        S \Rightarrow^* uXz \Rightarrow^* uvXyz  \Rightarrow^* uvvxyyz
    \end{equation*}
    is er eentje en $\ldots$, hierbij zijn de eerste twee voorwaarden bewezen van de stelling. \\

    We besluiten nu ook de laatste: $vxy$ wordt afgeleid door de deelboom onder $X_2$. Het deel van het geselecteerde pad onder $X_2$ is een langste pad van deze deelboom. Dit deelpad is hoogstens $n$ lang (het bestaat enkel uit niet-eindsymbolen, bevat niet $S$, en bevat exact 1 herhaald symbool $X$). Het aantal bladeren van deze deelboom, en dus de lengte van $vxy$ is dus hoogstens $2^{n-1} \leq p$, waarbij de laatste voorwaarde ook bewezen is.

\end{prf}

